From 9a762380209e40ce61bd2210620186a7afb4719b Mon Sep 17 00:00:00 2001
From: Cyril Hrubis <chrubis@suse.cz>
Date: Tue, 30 Apr 2013 12:57:09 +0200
Subject: [PATCH] syscalls/accept4: Fix test when accept4 returns ENOSYS

* Make the test actually exit with TCONF when accept4 returned ENOSYS

* Remove ifdefs around the main as due tu linux_syscall_numbers.h
  both __NR_accept4 and __NR_socketcall are always defined.

mem/ksm05: Add check for KSM sysfs existence.

Add check (the same as in ksm01) for the existence of KSM sysfs files.
Without it the testcase prints 665 lines of TBROK and then Segfaults on
systems without KSM support.

mem/thp03: Return TCONF if KSM is not supported

The madvise() with MADV_MERGEABLE will return EINVAL when kernel is not
compiled with KSM. Make the test return TCONF rather than TBROK in this
case.

openposix/.../pthread_key_create/speculative/5-1.c

* The pthread_key_create was called twice in the loop
  no wonder it failed with EAGAIN before the loop has
  reached the limit.

* Cleaned up the code a litte.

openposix/...pthread_mutexattr_gettype/speculative/3-1

The testcase tests for optional behavior. On linux the function just
returns member of the passed attr structure and as a such cannot fail.

This commit changes the test to return UNTESTED when the call succeeded.

Signed-off-by: Cyril Hrubis <chrubis@suse.cz>
---
 testcases/kernel/mem/ksm/ksm05.c                   |    4 +
 testcases/kernel/mem/thp/thp03.c                   |   12 +++-
 testcases/kernel/syscalls/accept4/accept4_01.c     |   14 ++--
 .../pthread_mutexattr_gettype/speculative/3-1.c    |   16 +++--
 5 files changed, 61 insertions(+), 46 deletions(-)

Index: ltp-full-20130109/testcases/kernel/mem/ksm/ksm05.c
===================================================================
--- ltp-full-20130109.orig/testcases/kernel/mem/ksm/ksm05.c
+++ ltp-full-20130109/testcases/kernel/mem/ksm/ksm05.c
@@ -151,7 +151,11 @@ void setup(void)
 	if (tst_kvercmp(2, 6, 32) < 0)
 		tst_brkm(TCONF, NULL, "2.6.32 or greater kernel required.");
 
+	if (access(PATH_KSM, F_OK) == -1)
+		tst_brkm(TCONF, NULL, "KSM configuration is not enabled");
+
 	tst_sig(FORK, sighandler, cleanup);
+
 	TEST_PAUSE;
 
 	/* save original /sys/kernel/mm/ksm/run value */
Index: ltp-full-20130109/testcases/kernel/mem/thp/thp03.c
===================================================================
--- ltp-full-20130109.orig/testcases/kernel/mem/thp/thp03.c
+++ ltp-full-20130109/testcases/kernel/mem/thp/thp03.c
@@ -44,6 +44,7 @@
 #include <fcntl.h>
 #include <stdlib.h>
 #include <string.h>
+#include <errno.h>
 #include "mem.h"
 #include "safe_macros.h"
 #include "test.h"
@@ -93,8 +94,15 @@ static void thp_test(void)
 	memset(p, 0x00, unaligned_size);
 	if (mprotect(p, unaligned_size, PROT_NONE) == -1)
 		tst_brkm(TBROK | TERRNO, cleanup, "mprotect");
-	if (madvise(p + hugepage_size, page_size, MADV_MERGEABLE) == -1)
-		tst_brkm(TBROK | TERRNO, cleanup, "madvise");
+
+	if (madvise(p + hugepage_size, page_size, MADV_MERGEABLE) == -1) {
+		if (errno == EINVAL) {
+			tst_brkm(TCONF, cleanup,
+			         "MADV_MERGEABLE is not enabled/supported");
+		} else {
+			tst_brkm(TBROK | TERRNO, cleanup, "madvise");
+		}
+	}
 
 	switch (fork()) {
 	case -1:
Index: ltp-full-20130109/testcases/kernel/syscalls/accept4/accept4_01.c
===================================================================
--- ltp-full-20130109.orig/testcases/kernel/syscalls/accept4/accept4_01.c
+++ ltp-full-20130109/testcases/kernel/syscalls/accept4/accept4_01.c
@@ -201,8 +201,12 @@ do_test(int lfd, struct sockaddr_in *con
 			   closeonexec_flag | nonblock_flag);
 #endif
 	if (acceptfd == -1) {
-		tst_resm(TCONF,
-			 "syscall __NR_accept4 not supported on your arch");
+		if (errno == ENOSYS) {
+			tst_brkm(TCONF, cleanup,
+			         "syscall __NR_accept4 not supported");
+		} else {
+			tst_brkm(TBROK | TERRNO, cleanup, "accept4 failed");
+		}
 	}
 
 	fdf = fcntl(acceptfd, F_GETFD);
@@ -272,7 +276,6 @@ static int create_listening_socket(int p
 
 int main(int argc, char *argv[])
 {
-#if defined(__NR_accept4) || defined(__NR_socketcall)
 	struct sockaddr_in conn_addr;
 	int lfd;
 	int port_num;
@@ -291,11 +294,8 @@ int main(int argc, char *argv[])
 	do_test(lfd, &conn_addr, SOCK_CLOEXEC, 0);
 	do_test(lfd, &conn_addr, 0, SOCK_NONBLOCK);
 	do_test(lfd, &conn_addr, SOCK_CLOEXEC, SOCK_NONBLOCK);
+	
 	close(lfd);
-#else
-	tst_resm(TCONF, "syscall __NR_accept4 not supported on your arch");
-#endif
-
 	cleanup();
 	tst_exit();
 }
Index: ltp-full-20130109/testcases/open_posix_testsuite/conformance/interfaces/pthread_mutexattr_gettype/speculative/3-1.c
===================================================================
--- ltp-full-20130109.orig/testcases/open_posix_testsuite/conformance/interfaces/pthread_mutexattr_gettype/speculative/3-1.c
+++ ltp-full-20130109/testcases/open_posix_testsuite/conformance/interfaces/pthread_mutexattr_gettype/speculative/3-1.c
@@ -37,13 +37,15 @@ int main()
 	/* Pass an invalid 'attr'.  */
 	ret = pthread_mutexattr_gettype(&mta, &type);
 
-	if (ret != EINVAL) {
-		printf
-		    ("Test FAILED: Incorrect return code.  Expected EINVAL, but got: %d\n",
-		     ret);
+	switch (ret) {
+	case 0:
+		printf("UNTESTED: The call didn't fail.\n");
+		return PTS_UNTESTED;
+	case EINVAL:
+		printf("Test PASSED\n");
+		return PTS_PASS;
+	default:
+		printf("Test FAILED: Expected EINVAL, but got: %d\n", ret);
 		return PTS_FAIL;
 	}
-
-	printf("Test PASSED\n");
-	return PTS_PASS;
 }
Index: ltp-full-20130109/testcases/open_posix_testsuite/conformance/interfaces/pthread_key_create/speculative/5-1.c
===================================================================
--- ltp-full-20130109.orig/testcases/open_posix_testsuite/conformance/interfaces/pthread_key_create/speculative/5-1.c
+++ ltp-full-20130109/testcases/open_posix_testsuite/conformance/interfaces/pthread_key_create/speculative/5-1.c
@@ -42,8 +42,6 @@ int main()
 
 	for (i = 0; i <= PTHREAD_KEYS_MAX; i++) {
 		rc = pthread_key_create(&keys[i], NULL);
-		pthread_key_t key;
-		rc = pthread_key_create(&key, NULL);
 		if (i == PTHREAD_KEYS_MAX) {
 			if (rc != EAGAIN) {
 				printf
