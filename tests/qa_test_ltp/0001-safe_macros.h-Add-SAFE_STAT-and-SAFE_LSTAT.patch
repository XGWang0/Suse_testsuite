From 8aeee2d2dbab3a9d8a796f3b146f0d611a8b2462 Mon Sep 17 00:00:00 2001
From: Cyril Hrubis <metan@ucw.cz>
Date: Thu, 6 Mar 2014 18:18:39 +0100
Subject: [PATCH 1/2] safe_macros.h: Add SAFE_STAT and SAFE_LSTAT
 safe_macros.h: Add SAFE_CHMOD syscalls/link: Cleanup + Fixes.

Signed-off-by: Cyril Hrubis <chrubis@suse.cz>
---
 include/safe_macros.h                   |  15 ++
 lib/safe_macros.c                       |  45 ++++
 testcases/kernel/syscalls/link/link02.c | 217 ++++--------------
 testcases/kernel/syscalls/link/link03.c | 272 ++++++----------------
 testcases/kernel/syscalls/link/link04.c | 388 ++++++--------------------------
 testcases/kernel/syscalls/link/link05.c | 279 +++++------------------
 testcases/kernel/syscalls/link/link06.c | 191 ++++------------
 testcases/kernel/syscalls/link/link07.c | 219 ++++--------------
 8 files changed, 372 insertions(+), 1254 deletions(-)

diff --git a/include/safe_macros.h b/include/safe_macros.h
index a9005b7..0ee8385 100644
--- a/include/safe_macros.h
+++ b/include/safe_macros.h
@@ -181,5 +181,20 @@ long safe_sysconf(const char *file, const int lineno,
 #define SAFE_SYSCONF(cleanup_fn, name) \
 	safe_sysconf(__FILE__, __LINE__, cleanup_fn, name)
 
+int safe_stat(const char *file, const int lineno, void (cleanup_fn)(void),
+              const char *path, struct stat *buf);
+#define SAFE_STAT(cleanup_fn, path, buf) \
+	safe_stat(__FILE__, __LINE__, (cleanup_fn), (path), (buf))
+
+int safe_lstat(const char *file, const int lineno, void (cleanup_fn)(void),
+               const char *path, struct stat *buf);
+#define SAFE_LSTAT(cleanup_fn, path, buf) \
+	safe_lstat(__FILE__, __LINE__, (cleanup_fn), (path), (buf))
+
+int safe_chmod(const char *file, const int lineno, void (cleanup_fn)(void),
+	       const char *path, mode_t mode);
+#define SAFE_CHMOD(cleanup_fn, path, mode) \
+	safe_chmod(__FILE__, __LINE__, (cleanup_fn), (path), (mode))
+
 #endif /* __SAFE_MACROS_H__ */
 #endif /* __TEST_H__ */
diff --git a/lib/safe_macros.c b/lib/safe_macros.c
index 8ecdff3..890577b 100644
--- a/lib/safe_macros.c
+++ b/lib/safe_macros.c
@@ -455,3 +455,48 @@ long safe_sysconf(const char *file, const int lineno,
 
 	return rval;
 }
+
+int safe_stat(const char *file, const int lineno,
+	      void (cleanup_fn)(void), const char *path, struct stat *buf)
+{
+	int rval;
+
+	rval = stat(path, buf);
+
+	if (rval == -1) {
+		tst_brkm(TBROK | TERRNO, cleanup_fn,
+			 "stat failed at %s:%d", file, lineno);
+	}
+
+	return rval;
+}
+
+int safe_lstat(const char *file, const int lineno,
+	       void (cleanup_fn)(void), const char *path, struct stat *buf)
+{
+	int rval;
+
+	rval = lstat(path, buf);
+
+	if (rval == -1) {
+		tst_brkm(TBROK | TERRNO, cleanup_fn,
+			 "lstat failed at %s:%d", file, lineno);
+	}
+
+	return rval;
+}
+
+int safe_chmod(const char *file, const int lineno,
+               void (cleanup_fn)(void), const char *path, mode_t mode)
+{
+	int rval;
+
+	rval = chmod(path, mode);
+
+	if (rval == -1) {
+		tst_brkm(TBROK | TERRNO, cleanup_fn,
+			 "chmod failed at %s:%d", file, lineno);
+	}
+
+	return rval;
+}
diff --git a/testcases/kernel/syscalls/link/link02.c b/testcases/kernel/syscalls/link/link02.c
index 35cd614..76fb61c 100644
--- a/testcases/kernel/syscalls/link/link02.c
+++ b/testcases/kernel/syscalls/link/link02.c
@@ -1,5 +1,8 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
+ *  AUTHOR		: William Roske
+ *  CO-PILOT		: Dave Fenner
+ * Copyright (c) 2014 Cyril Hrubis <chrubis@suse.cz>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -28,86 +31,11 @@
  * For further information regarding this notice, see:
  *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
- *
  */
-/* $Id: link02.c,v 1.5 2009/10/26 14:55:47 subrata_modak Exp $ */
-/**********************************************************
- *
- *    OS Test - Silicon Graphics, Inc.
- *
- *    TEST IDENTIFIER	: link02
- *
- *    EXECUTED BY	: anyone
- *
- *    TEST TITLE	: Basic test for link(2)
- *
- *    PARENT DOCUMENT	: usctpl01
- *
- *    TEST CASE TOTAL	: 1
- *
- *    WALL CLOCK TIME	: 1
- *
- *    CPU TYPES		: ALL
- *
- *    AUTHOR		: William Roske
- *
- *    CO-PILOT		: Dave Fenner
- *
- *    DATE STARTED	: 03/30/92
- *
- *    INITIAL RELEASE	: UNICOS 7.0
- *
- *    TEST CASES
- *
- * 	1.) link(2) returns...(See Description)
- *
- *    INPUT SPECIFICATIONS
- * 	The standard options for system call tests are accepted.
- *	(See the parse_opts(3) man page).
- *
- *    OUTPUT SPECIFICATIONS
- *$
- *    DURATION
- * 	Terminates - with frequency and infinite modes.
- *
- *    SIGNALS
- * 	Uses SIGUSR1 to pause before test if option set.
- * 	(See the parse_opts(3) man page).
- *
- *    RESOURCES
- * 	None
- *
- *    ENVIRONMENTAL NEEDS
- *      No run-time environmental needs.
- *
- *    SPECIAL PROCEDURAL REQUIREMENTS
- * 	None
- *
- *    INTERCASE DEPENDENCIES
- * 	None
- *
- *    DETAILED DESCRIPTION
- *	This is a Phase I test for the link(2) system call.  It is intended
- *	to provide a limited exposure of the system call, for now.  It
- *	should/will be extended when full functional tests are written for
- *	link(2).
- *
- * 	Setup:
- * 	  Setup signal handling.
- *	  Pause for SIGUSR1 if option specified.
- *
- * 	Test:
- *	 Loop if the proper options are given.
- * 	  Execute system call
- *	  Check return code, if system call failed (return=-1)
- *		Log the errno and Issue a FAIL message.
- *	  Otherwise, Issue a PASS message.
- *
- * 	Cleanup:
- * 	  Print errno log and/or timing stats if options given
- *
- *
- *#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#**/
+
+/*
+ * Tests that link(2) succeds.
+ */
 
 #include <sys/types.h>
 #include <sys/fcntl.h>
@@ -117,136 +45,75 @@
 #include <signal.h>
 #include "test.h"
 #include "usctest.h"
+#include "safe_macros.h"
 
-void setup();
-void cleanup();
+static void setup(void);
+static void cleanup(void);
 
 char *TCID = "link02";
 int TST_TOTAL = 1;
 
-int exp_enos[] = { 0, 0 };
+#define OLDPATH "oldpath"
+#define NEWPATH "newpath"
+
+static void verify_link(void)
+{
+	struct stat fbuf, lbuf;
+
+	TEST(link(OLDPATH, NEWPATH));
 
-char Fname[255], Lname[255];
+	if (TEST_RETURN == 0) {
+		SAFE_STAT(cleanup, OLDPATH, &fbuf);
+		SAFE_STAT(cleanup, NEWPATH, &lbuf);
+		if (fbuf.st_nlink > 1 && lbuf.st_nlink > 1 &&
+		    fbuf.st_nlink == lbuf.st_nlink) {
+			tst_resm(TPASS, "link("OLDPATH","NEWPATH") "
+			         "returned 0 and link counts match");
+		} else {
+			tst_resm(TFAIL, "link("OLDPATH","NEWPATH") returned 0"
+				 " but stat lin count do not match %d %d",
+				 (int)fbuf.st_nlink, (int)lbuf.st_nlink);
+		}
+		SAFE_UNLINK(cleanup, NEWPATH);
+	} else {
+		tst_resm(TFAIL | TTERRNO,
+		         "link("OLDPATH","NEWPATH") returned %ld",
+		         TEST_RETURN);
+	}
+}
 
-/***********************************************************************
- * Main
- ***********************************************************************/
 int main(int ac, char **av)
 {
 	int lc;
 	char *msg;
-	struct stat fbuf, lbuf;
 
-    /***************************************************************
-     * parse standard options
-     ***************************************************************/
-	if ((msg = parse_opts(ac, av, NULL, NULL)) != NULL) {
+	if ((msg = parse_opts(ac, av, NULL, NULL)) != NULL)
 		tst_brkm(TBROK, NULL, "OPTION PARSING ERROR - %s", msg);
 
-	}
-
-    /***************************************************************
-     * perform global setup for test
-     ***************************************************************/
 	setup();
 
-	/* set the expected errnos... */
-	TEST_EXP_ENOS(exp_enos);
-
-    /***************************************************************
-     * check looping state if -c option given
-     ***************************************************************/
 	for (lc = 0; TEST_LOOPING(lc); lc++) {
-
 		tst_count = 0;
-
-		/*
-		 *  Call link(2)
-		 */
-		TEST(link(Fname, Lname));
-
-		/* check return code */
-		if (TEST_RETURN == -1) {
-			TEST_ERROR_LOG(TEST_ERRNO);
-			tst_resm(TFAIL, "link(%s, %s) Failed, errno=%d : %s",
-				 Fname, Lname, TEST_ERRNO,
-				 strerror(TEST_ERRNO));
-		} else {
-
-	    /***************************************************************
-	     * only perform functional verification if flag set (-f not given)
-	     ***************************************************************/
-			if (STD_FUNCTIONAL_TEST) {
-				/* No Verification test, yet... */
-				stat(Fname, &fbuf);
-				stat(Lname, &lbuf);
-				if (fbuf.st_nlink > 1 && lbuf.st_nlink > 1 &&
-				    fbuf.st_nlink == lbuf.st_nlink)
-
-					tst_resm(TPASS,
-						 "link(%s, %s) returned %ld and link cnts match",
-						 Fname, Lname, TEST_RETURN);
-				else {
-					tst_resm(TFAIL,
-						 "link(%s, %s) returned %ld, stat link cnts do not match %d %d",
-						 Fname, Lname, TEST_RETURN,
-						 fbuf.st_nlink, lbuf.st_nlink);
-				}
-			}
-			if (unlink(Lname) == -1) {
-				tst_resm(TWARN,
-					 "unlink(%s) Failed, errno=%d : %s",
-					 Fname, errno, strerror(errno));
-			}
-		}
-
+		verify_link();
 	}
 
-    /***************************************************************
-     * cleanup and exit
-     ***************************************************************/
 	cleanup();
 	tst_exit();
-
 }
 
-/***************************************************************
- * setup() - performs all ONE TIME setup for this test.
- ***************************************************************/
-void setup()
+static void setup(void)
 {
-	int fd;
-
 	tst_sig(NOFORK, DEF_HANDLER, cleanup);
 
 	TEST_PAUSE;
 
 	tst_tmpdir();
 
-	strcpy(Fname, "tfile");
-	if ((fd = open(Fname, O_RDWR | O_CREAT, 0700)) == -1) {
-		tst_brkm(TBROK, cleanup,
-			 "open(%s, O_RDWR|O_CREAT, 0700) Failed, errno=%d : %s",
-			 Fname, errno, strerror(errno));
-	} else if (close(fd) == -1) {
-		tst_resm(TWARN, "close(%s) Failed, errno=%d : %s",
-			 Fname, errno, strerror(errno));
-	}
-	strcpy(Lname, "lfile");
+	SAFE_TOUCH(cleanup, OLDPATH, 0700, NULL);
 }
 
-/***************************************************************
- * cleanup() - performs all ONE TIME cleanup for this test at
- *		completion or premature exit.
- ***************************************************************/
-void cleanup()
+static void cleanup(void)
 {
-	/*
-	 * print timing stats if that option was specified.
-	 * print errno log if that option was specified.
-	 */
 	TEST_CLEANUP;
-
 	tst_rmdir();
-
 }
diff --git a/testcases/kernel/syscalls/link/link03.c b/testcases/kernel/syscalls/link/link03.c
index 5a0d337..ae2db2d 100644
--- a/testcases/kernel/syscalls/link/link03.c
+++ b/testcases/kernel/syscalls/link/link03.c
@@ -1,5 +1,8 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
+ *  AUTHOR		: Richard Logan
+ *  CO-PILOT		: William Roske
+ * Copyright (c) 2014 Cyril Hrubis <chrubis@suse.cz>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -30,85 +33,10 @@
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  *
  */
-/* $Id: link03.c,v 1.5 2009/10/26 14:55:47 subrata_modak Exp $ */
-/**********************************************************
- *
- *    OS Test - Silicon Graphics, Inc.
- *
- *    TEST IDENTIFIER	: link03
- *
- *    EXECUTED BY	: anyone
- *
- *    TEST TITLE	: multi links tests
- *
- *    PARENT DOCUMENT	: usctpl01
- *
- *    TEST CASE TOTAL	: 2
- *
- *    WALL CLOCK TIME	: 1
- *
- *    CPU TYPES		: ALL
- *
- *    AUTHOR		: Richard Logan
- *
- *    CO-PILOT		: William Roske
- *
- *    DATE STARTED	: 03/31/94
- *
- *    INITIAL RELEASE	: UNICOS 7.0
- *
- *    TEST CASES
- *
- * 	1.) link(2) returns...(See Description)
- *
- *    INPUT SPECIFICATIONS
- * 	The standard options for system call tests are accepted.
- *	(See the parse_opts(3) man page).
- *	-N #links : Use #links links every iteration
- *
- *    OUTPUT SPECIFICATIONS
- *$
- *    DURATION
- * 	Terminates - with frequency and infinite modes.
- *
- *    SIGNALS
- * 	Uses SIGUSR1 to pause before test if option set.
- * 	(See the parse_opts(3) man page).
- *
- *    RESOURCES
- * 	None
- *
- *    ENVIRONMENTAL NEEDS
- *      No run-time environmental needs.
- *
- *    SPECIAL PROCEDURAL REQUIREMENTS
- * 	None
- *
- *    INTERCASE DEPENDENCIES
- * 	None
- *
- *    DETAILED DESCRIPTION
- *	This is a Phase I test for the link(2) system call.  It is intended
- *	to provide a limited exposure of the system call, for now.  It
- *	should/will be extended when full functional tests are written for
- *	link(2).
- *
- * 	Setup:
- * 	  Setup signal handling.
- *	  Pause for SIGUSR1 if option specified.
- *
- * 	Test:
- *	 Loop if the proper options are given.
- * 	  Execute system call
- *	  Check return code, if system call failed (return=-1)
- *		Log the errno and Issue a FAIL message.
- *	  Otherwise, Issue a PASS message.
- *
- * 	Cleanup:
- * 	  Print errno log and/or timing stats if options given
- *
- *
- *#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#**/
+
+ /*
+  * Tests that link(2) succeds with creating n links.
+  */
 
 #include <sys/types.h>
 #include <sys/fcntl.h>
@@ -118,198 +46,126 @@
 #include <signal.h>
 #include "test.h"
 #include "usctest.h"
+#include "safe_macros.h"
 
-void setup();
-void help();
-void cleanup();
+static void setup(void);
+static void help(void);
+static void cleanup(void);
 
 char *TCID = "link03";
 int TST_TOTAL = 2;
 
-int exp_enos[] = { 0, 0 };
-
 #define BASENAME	"lkfile"
 
-char Basename[255];
-char Fname[255];
-int Nlinks = 0;
-char *Nlinkarg;
-
-int Nflag = 0;
+static char fname[255];
+static int nlinks = 0;
+static char *links_arg;
 
-/* for test specific parse_opts options */
 option_t options[] = {
-	{"N:", &Nflag, &Nlinkarg},	/* -N #links */
+	{"N:", NULL, &links_arg},
 	{NULL, NULL, NULL}
 };
 
-/***********************************************************************
- * Main
- ***********************************************************************/
 int main(int ac, char **av)
 {
 	int lc;
 	char *msg;
-	struct stat fbuf, lbuf;
-	int cnt;
-	int nlinks;
+	struct stat buf;
+	int i, links;
 	char lname[255];
 
-    /***************************************************************
-     * parse standard options
-     ***************************************************************/
-	if ((msg = parse_opts(ac, av, options, &help)) != NULL) {
+	if ((msg = parse_opts(ac, av, options, &help)) != NULL)
 		tst_brkm(TBROK, NULL, "OPTION PARSING ERROR - %s", msg);
-		tst_exit();
-	}
 
-	if (Nflag) {
-		if (sscanf(Nlinkarg, "%i", &Nlinks) != 1) {
-			tst_brkm(TBROK, NULL, "--N option arg is not a number");
-			tst_exit();
+	if (links_arg) {
+		nlinks = atoi(links_arg);
+
+		if (nlinks == 0) {
+			tst_brkm(TBROK, NULL,
+			         "nlinks is not a positive number");
 		}
-		if (Nlinks > 1000) {
-			tst_resm(TWARN,
-				 "--N option arg > 1000 - may get errno:%d (EMLINK)",
+
+		if (nlinks > 1000) {
+			tst_resm(TINFO,
+				 "nlinks > 1000 - may get errno:%d (EMLINK)",
 				 EMLINK);
 		}
 	}
 
-    /***************************************************************
-     * perform global setup for test
-     ***************************************************************/
 	setup();
 
-	/* set the expected errnos... */
-	TEST_EXP_ENOS(exp_enos);
-
-    /***************************************************************
-     * check looping state if -c option given
-     ***************************************************************/
 	for (lc = 0; TEST_LOOPING(lc); lc++) {
-
 		tst_count = 0;
 
-		if (Nlinks)
-			nlinks = Nlinks;
+		if (nlinks)
+			links = nlinks;
 		else
-			/* min of 10 links and max of a 100 links */
-			nlinks = (lc % 90) + 10;
-
-		for (cnt = 1; cnt < nlinks; cnt++) {
+			links = (lc % 90) + 10;
 
-			sprintf(lname, "%s%d", Basename, cnt);
-			/*
-			 *  Call link(2)
-			 */
-			TEST(link(Fname, lname));
+		/* Create links - 1 hardlinks so that the st_nlink == links */
+		for (i = 1; i < links; i++) {
+			sprintf(lname, "%s%d", fname, i);
+			TEST(link(fname, lname));
 
-			/* check return code */
 			if (TEST_RETURN == -1) {
-				TEST_ERROR_LOG(TEST_ERRNO);
-				tst_brkm(TFAIL, cleanup,
-					 "link(%s, %s) Failed, errno=%d : %s",
-					 Fname, lname, TEST_ERRNO,
-					 strerror(TEST_ERRNO));
+				tst_brkm(TFAIL | TTERRNO, cleanup,
+					 "link(%s, %s) Failed", fname, lname);
 			}
 		}
 
-	/***************************************************************
-	 * only perform functional verification if flag set (-f not given)
-	 ***************************************************************/
-		if (STD_FUNCTIONAL_TEST) {
-			stat(Fname, &fbuf);
+		SAFE_STAT(cleanup, fname, &buf);
 
-			for (cnt = 1; cnt < nlinks; cnt++) {
-				sprintf(lname, "%s%d", Basename, cnt);
-
-				stat(lname, &lbuf);
-				if (fbuf.st_nlink <= 1 || lbuf.st_nlink <= 1 ||
-				    (fbuf.st_nlink != lbuf.st_nlink)) {
+		if (buf.st_nlink != (nlink_t)links) {
+			tst_resm(TFAIL, "Wrong number of links for "
+			         "'%s' have %i, should be %i",
+				 fname, (int)buf.st_nlink, links);
+			goto unlink;
+		}
 
-					tst_resm(TFAIL,
-						 "link(%s, %s[1-%d]) ret %ld for %d files, stat values do not match %d %d",
-						 Fname, Basename, nlinks,
-						 TEST_RETURN, nlinks,
-						 fbuf.st_nlink, lbuf.st_nlink);
-					break;
-				}
-			}
-			if (cnt >= nlinks) {
-				tst_resm(TPASS,
-					 "link(%s, %s[1-%d]) ret %ld for %d files, stat linkcounts match %d",
-					 Fname, Basename, nlinks, TEST_RETURN,
-					 nlinks, fbuf.st_nlink);
+		for (i = 1; i < links; i++) {
+			sprintf(lname, "%s%d", fname, i);
+			SAFE_STAT(cleanup, lname, &buf);
+			if (buf.st_nlink != (nlink_t)links) {
+				tst_resm(TFAIL,
+				         "Wrong number of links for "
+					 "'%s' have %i, should be %i",
+					 lname, (int)buf.st_nlink, links);
+				goto unlink;
 			}
-		} else
-			tst_count++;
-
-		for (cnt = 1; cnt < nlinks; cnt++) {
+		}
 
-			sprintf(lname, "%s%d", Basename, cnt);
+		tst_resm(TPASS, "link() passed and linkcounts=%d match", links);
 
-			if (unlink(lname) == -1) {
-				tst_res(TWARN,
-					"unlink(%s) Failed, errno=%d : %s",
-					Fname, errno, strerror(errno));
-			}
+unlink:
+		for (i = 1; i < links; i++) {
+			sprintf(lname, "%s%d", fname, i);
+			SAFE_UNLINK(cleanup, lname);
 		}
-
 	}
 
-    /***************************************************************
-     * cleanup and exit
-     ***************************************************************/
 	cleanup();
-
 	tst_exit();
 }
 
-/***************************************************************
- * help
- ***************************************************************/
-void help()
+static void help(void)
 {
 	printf("  -N #links : create #links hard links every iteration\n");
 }
 
-/***************************************************************
- * setup() - performs all ONE TIME setup for this test.
- ***************************************************************/
-void setup()
+static void setup(void)
 {
-	int fd;
-
 	tst_sig(NOFORK, DEF_HANDLER, cleanup);
 
 	TEST_PAUSE;
 
 	tst_tmpdir();
 
-	sprintf(Fname, "%s_%d", BASENAME, getpid());
-	if ((fd = open(Fname, O_RDWR | O_CREAT, 0700)) == -1) {
-		tst_brkm(TBROK, cleanup,
-			 "open(%s, O_RDWR|O_CREAT,0700) Failed, errno=%d : %s",
-			 Fname, errno, strerror(errno));
-	} else if (close(fd) == -1) {
-		tst_res(TWARN, "close(%s) Failed, errno=%d : %s",
-			Fname, errno, strerror(errno));
-	}
-	sprintf(Basename, "%s_%d.", BASENAME, getpid());
+	sprintf(fname, "%s_%d", BASENAME, getpid());
+	SAFE_TOUCH(cleanup, fname, 0700, NULL);
 }
 
-/***************************************************************
- * cleanup() - performs all ONE TIME cleanup for this test at
- *		completion or premature exit.
- ***************************************************************/
-void cleanup()
+static void cleanup(void)
 {
-	/*
-	 * print timing stats if that option was specified.
-	 * print errno log if that option was specified.
-	 */
 	TEST_CLEANUP;
-
 	tst_rmdir();
-
 }
diff --git a/testcases/kernel/syscalls/link/link04.c b/testcases/kernel/syscalls/link/link04.c
index 1a023e4..e6670f7 100644
--- a/testcases/kernel/syscalls/link/link04.c
+++ b/testcases/kernel/syscalls/link/link04.c
@@ -1,5 +1,8 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
+ *  AUTHOR		: Richard Logan
+ *  CO-PILOT		: William Roske
+ * Copyright (c) 2014 Cyril Hrubis <chrubis@suse.cz>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -30,118 +33,31 @@
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
  *
  */
-/* $Id: link04.c,v 1.9 2009/10/26 14:55:47 subrata_modak Exp $ */
-/**********************************************************
- *
- *    OS Test - Silicon Graphics, Inc.
- *
- *    TEST IDENTIFIER	: link04
- *
- *    EXECUTED BY	: anyone
- *
- *    TEST TITLE	: Negative test cases for link(2).
- *
- *    PARENT DOCUMENT	: usctpl01
- *
- *    TEST CASE TOTAL	: 14
- *
- *    WALL CLOCK TIME	: 1
- *
- *    CPU TYPES		: ALL
- *
- *    AUTHOR		: Richard Logan
- *
- *    CO-PILOT		: William Roske
- *
- *    DATE STARTED	: 03/30/94
- *
- *    INITIAL RELEASE	: UNICOS 7.0
- *
- *    TEST CASES
- *
- * 	1-14.) link(2) returns...(See Test_cases structure below)
- *
- *    INPUT SPECIFICATIONS
- * 	The standard options for system call tests are accepted.
- *	(See the parse_opts(3) man page).
- *
- *    OUTPUT SPECIFICATIONS
- *	Standard tst_res output formt.
- *$
- *    DURATION
- * 	Terminates - with frequency and infinite modes.
- *
- *    SIGNALS
- * 	Uses SIGUSR1 to pause before test if option set.
- * 	(See the parse_opts(3) man page).
- *
- *    RESOURCES
- * 	None
- *
- *    ENVIRONMENTAL NEEDS
- *      No run-time environmental needs.
- *
- *    SPECIAL PROCEDURAL REQUIREMENTS
- * 	None
- *
- *    INTERCASE DEPENDENCIES
- * 	None
- *
- *    DETAILED DESCRIPTION
- *	This is a Phase I test for the link(2) system call.  It is intended
- *	to provide a limited exposure of the system call, for now.  It
- *	should/will be extended when full functional tests are written for
- *	link(2).
- *
- * 	Setup:
- * 	  Setup signal handling.
- *	  Pause for SIGUSR1 if option specified.
- *
- * 	Test:
- *	 Loop if the proper options are given.
- * 	  Execute system call
- *	  Check return code, if system call failed (return=-1)
- *		Log the errno and Issue a FAIL message.
- *	  Otherwise, Issue a PASS message.
- *
- * 	Cleanup:
- * 	  Print errno log and/or timing stats if options given
- *
- *
- *#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#**/
 
+/*
+ * Negative test cases for link(2).
+ *
+ * This test program should contain test cases where link will fail regardless
+ * of who executed it (i.e. joe-user or root)
+ */
 #include <sys/types.h>
 #include <sys/fcntl.h>
 #include <sys/stat.h>
 #include <errno.h>
 #include <string.h>
 #include <signal.h>
-#include <sys/param.h>		/* for PATH_MAX */
+#include <sys/param.h>
 #include <sys/mman.h>
 #include "test.h"
 #include "usctest.h"
+#include "safe_macros.h"
 
-void setup();
-void cleanup();
+static char *bad_addr = 0;
 
-extern char *get_high_address();
-
-char *TCID = "link04";
-int TST_TOTAL = 14;
-
-int exp_enos[] = { 0, 0 };
-
-char *bad_addr = 0;
-
-int longpath_setup();
-int no_setup();
-int filepath_setup();
-int filepath2_setup();
-char Longpathname[PATH_MAX + 2];
+static char longpath[PATH_MAX + 2];
 #if !defined(UCLINUX)
-char High_address[64];
+char high_addr[64];
 #endif
-int dir_setup();
 
 struct test_case_t {
 	char *file1;
@@ -149,154 +65,104 @@ struct test_case_t {
 	char *file2;
 	char *desc2;
 	int exp_errno;
-	int (*setupfunc1) ();
-	int (*setupfunc2) ();
-} Test_cases[] = {
-	/* This test program should contain test cases where link */
-	/* will fail regardless of who executed it (i.e. joe-user or root) */
-
+} test_cases[] = {
 	/* first path is invalid */
-
-	{
-	"nonexistfile", "non-existent file", "nefile", "nefile",
-		    ENOENT, no_setup, no_setup}, {
-	"", "path is empty string", "nefile", "nefile",
-		    ENOENT, no_setup, no_setup}, {
-	"neefile/file", "path contains a non-existent file", "nefile",
-		    "nefile", ENOENT, no_setup, no_setup}, {
-	"regfile/file", "path contains a regular file", "nefile",
-		    "nefile", ENOTDIR, filepath_setup, no_setup}, {
-	Longpathname, "pathname too long", "nefile", "nefile",
-		    ENAMETOOLONG, longpath_setup, no_setup},
+	{"nonexistfile", "non-existent file", "nefile", "nefile", ENOENT},
+	{"", "path is empty string", "nefile", "nefile", ENOENT},
+	{"neefile/file", "path contains a non-existent file", "nefile",
+	 "nefile", ENOENT},
+	{"regfile/file", "path contains a regular file", "nefile", "nefile",
+	 ENOTDIR},
+	{longpath, "pathname too long", "nefile", "nefile", ENAMETOOLONG},
 #if !defined(UCLINUX)
-	{
-	High_address, "address beyond address space", "nefile",
-		    "nefile", EFAULT, no_setup, no_setup},
+	{high_addr, "address beyond address space", "nefile", "nefile", EFAULT},
 #endif
-	{
-	(char *)-1, "negative address", "nefile", "nefile",
-		    EFAULT, no_setup, no_setup},
-	    /* second path is invalid */
-	{
-	"regfile", "regfile", "", "empty string",
-		    ENOENT, no_setup, no_setup}, {
-	"regfile", "regfile", "neefile/file",
-		    "path contains a non-existent file", ENOENT,
-		    filepath_setup, no_setup}, {
-	"regfile", "regfile", "file/file",
-		    "path contains a regular file", ENOENT,
-		    filepath_setup, no_setup}, {
-	"regfile", "regfile", Longpathname, "pathname too long",
-		    ENAMETOOLONG, no_setup, longpath_setup},
+	{(char *)-1, "negative address", "nefile", "nefile", EFAULT},
+	/* second path is invalid */
+	{"regfile", "regfile", "", "empty string", ENOENT},
+	{"regfile", "regfile", "neefile/file",
+		    "path contains a non-existent file", ENOENT},
+	{"regfile", "regfile", "file/file",
+		    "path contains a regular file", ENOENT},
+	{"regfile", "regfile", longpath, "pathname too long", ENAMETOOLONG},
 #if !defined(UCLINUX)
-	{
-	"regfile", "regfile", High_address,
-		    "address beyond address space", EFAULT, no_setup, no_setup},
+	{"regfile", "regfile", high_addr,
+		    "address beyond address space", EFAULT},
 #endif
-	{
-	"regfile", "regfile", (char *)-1, "negative address",
-		    EFAULT, no_setup, no_setup},
-	    /* two existing files */
-	{
-	"regfile", "regfile", "regfile2", "regfile2",
-		    EEXIST, filepath_setup, filepath2_setup}, {
-	NULL, NULL, NULL, NULL, 0, no_setup, no_setup}
+	{"regfile", "regfile", (char *)-1, "negative address", EFAULT},
+	/* two existing files */
+	{"regfile", "regfile", "regfile2", "regfile2", EEXIST},
 };
 
-/***********************************************************************
- * Main
- ***********************************************************************/
+char *TCID = "link04";
+int TST_TOTAL = ARRAY_SIZE(test_cases);
+
+static void setup(void);
+static void cleanup(void);
+
 int main(int ac, char **av)
 {
 	int lc;
 	char *msg;
 	char *fname1, *fname2;
 	char *desc1, *desc2;
-	int ind;
+	int i;
 
-    /***************************************************************
-     * parse standard options
-     ***************************************************************/
-	if ((msg = parse_opts(ac, av, NULL, NULL)) != NULL) {
+	if ((msg = parse_opts(ac, av, NULL, NULL)) != NULL)
 		tst_brkm(TBROK, NULL, "OPTION PARSING ERROR - %s", msg);
-		tst_exit();
-	}
 
-    /***************************************************************
-     * perform global setup for test
-     ***************************************************************/
 	setup();
 
-    /***************************************************************
-     * check looping state if -c option given
-     ***************************************************************/
 	for (lc = 0; TEST_LOOPING(lc); lc++) {
 
 		tst_count = 0;
 
-		for (ind = 0; Test_cases[ind].desc1 != NULL; ind++) {
+		for (i = 0; i < TST_TOTAL; i++) {
 
-			fname1 = Test_cases[ind].file1;
-			desc1 = Test_cases[ind].desc1;
-			fname2 = Test_cases[ind].file2;
-			desc2 = Test_cases[ind].desc2;
+			fname1 = test_cases[i].file1;
+			desc1 = test_cases[i].desc1;
+			fname2 = test_cases[i].file2;
+			desc2 = test_cases[i].desc2;
 
 #if !defined(UCLINUX)
-			if (fname1 == High_address)
+			if (fname1 == high_addr)
 				fname1 = get_high_address();
 
-			if (fname2 == High_address)
+			if (fname2 == high_addr)
 				fname2 = get_high_address();
 #endif
 
-			/*
-			 *  Call link(2)
-			 */
 			TEST(link(fname1, fname2));
 
-			/* check return code */
 			if (TEST_RETURN == -1) {
-				if (STD_FUNCTIONAL_TEST) {
-					if (TEST_ERRNO ==
-					    Test_cases[ind].exp_errno)
-						tst_resm(TPASS,
-							 "link(<%s>, <%s>) Failed, errno=%d",
-							 desc1, desc2,
-							 TEST_ERRNO);
-					else
-						tst_resm(TFAIL,
-							 "link(<%s>, <%s>) Failed, errno=%d, expected errno:%d",
-							 desc1, desc2,
-							 TEST_ERRNO,
-							 Test_cases
-							 [ind].exp_errno);
-				} else
-					tst_count++;
+				if (TEST_ERRNO == test_cases[i].exp_errno) {
+					tst_resm(TPASS | TTERRNO,
+						 "link(<%s>, <%s>)",
+						 desc1, desc2);
+				} else {
+					tst_resm(TFAIL | TTERRNO,
+						 "link(<%s>, <%s>) Failed "
+					         "expected errno: %d",
+						 desc1, desc2,
+						 test_cases[i].exp_errno);
+				}
 			} else {
 				tst_resm(TFAIL,
-					 "link(<%s>, <%s>) returned %ld, expected -1, errno:%d",
+					 "link(<%s>, <%s>) returned %ld, "
+				         "expected -1, errno:%d",
 					 desc1, desc2, TEST_RETURN,
-					 Test_cases[ind].exp_errno);
+					 test_cases[i].exp_errno);
 			}
 		}
 
 	}
 
-    /***************************************************************
-     * cleanup and exit
-     ***************************************************************/
 	cleanup();
-
 	tst_exit();
 }
 
-/***************************************************************
- * setup() - performs all ONE TIME setup for this test.
- ***************************************************************/
-void setup()
+static void setup(void)
 {
-	int ind;
-
 	tst_sig(NOFORK, DEF_HANDLER, cleanup);
 
 	TEST_PAUSE;
@@ -304,124 +170,20 @@ void setup()
 	tst_tmpdir();
 
 #if !defined(UCLINUX)
-	bad_addr = mmap(0, 1, PROT_NONE,
-			MAP_PRIVATE_EXCEPT_UCLINUX | MAP_ANONYMOUS, 0, 0);
-	if (bad_addr == MAP_FAILED) {
-		tst_brkm(TBROK, cleanup, "mmap failed");
-	}
-	Test_cases[6].file1 = bad_addr;
-	Test_cases[12].file2 = bad_addr;
+	bad_addr = SAFE_MMAP(cleanup, 0, 1, PROT_NONE,
+	                     MAP_PRIVATE_EXCEPT_UCLINUX | MAP_ANONYMOUS, 0, 0);
+	test_cases[6].file1 = bad_addr;
+	test_cases[12].file2 = bad_addr;
 #endif
 
-	for (ind = 0; Test_cases[ind].desc1 != NULL; ind++) {
-		Test_cases[ind].setupfunc1();
-		Test_cases[ind].setupfunc2();
-	}
-
+	memset(longpath, 'a', PATH_MAX+1);
+	SAFE_TOUCH(cleanup, "regfile", 0777, NULL);
+	SAFE_TOUCH(cleanup, "regfile2", 0777, NULL);
+	SAFE_MKDIR(cleanup, "dir", 0777);
 }
 
-/***************************************************************
- * cleanup() - performs all ONE TIME cleanup for this test at
- *		completion or premature exit.
- ***************************************************************/
-void cleanup()
+static void cleanup(void)
 {
-	/*
-	 * print timing stats if that option was specified.
-	 * print errno log if that option was specified.
-	 */
 	TEST_CLEANUP;
-
 	tst_rmdir();
-
-}
-
-/******************************************************************
- *
- ******************************************************************/
-int no_setup()
-{
-	return 0;
-}
-
-/******************************************************************
- *
- ******************************************************************/
-int longpath_setup()
-{
-	int ind;
-
-	static int alreadycalled = 0;
-
-	if (alreadycalled)
-		return 0;
-	alreadycalled++;
-
-	for (ind = 0; ind <= PATH_MAX + 1; ind++) {
-		Longpathname[ind] = 'a';
-	}
-	return 0;
-
-}
-
-/******************************************************************
- *
- ******************************************************************/
-int filepath2_setup()
-{
-	int fd;
-	static int alreadycalled = 0;
-
-	if (alreadycalled)
-		return 0;
-	alreadycalled++;
-
-	if ((fd = creat("regfile2", 0777)) == -1) {
-		tst_brkm(TBROK, cleanup,
-			 "creat(regfile2, 0777) failed, errno:%d %s", errno,
-			 strerror(errno));
-	}
-	close(fd);
-	return 0;
-}
-
-/******************************************************************
- *
- ******************************************************************/
-int filepath_setup()
-{
-	int fd;
-	static int alreadycalled = 0;
-
-	if (alreadycalled)
-		return 0;
-	alreadycalled++;
-
-	if ((fd = creat("regfile", 0777)) == -1) {
-		tst_brkm(TBROK, cleanup,
-			 "creat(regfile, 0777) failed, errno:%d %s", errno,
-			 strerror(errno));
-	}
-	close(fd);
-	return 0;
-}
-
-/******************************************************************
- *
- ******************************************************************/
-int dir_setup()
-{
-	static int alreadycalled = 0;
-
-	if (alreadycalled)
-		return 0;
-	alreadycalled++;
-
-	if (mkdir("dir", 0777) == -1) {
-		tst_brkm(TBROK, cleanup,
-			 "mkdir(dir, 0700) Failed, errno=%d : %s",
-			 errno, strerror(errno));
-	}
-
-	return 0;
 }
diff --git a/testcases/kernel/syscalls/link/link05.c b/testcases/kernel/syscalls/link/link05.c
index ef772fe..b5a3ac9 100644
--- a/testcases/kernel/syscalls/link/link05.c
+++ b/testcases/kernel/syscalls/link/link05.c
@@ -1,5 +1,8 @@
 /*
  * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
+ *  AUTHOR		: Richard Logan
+ *  CO-PILOT		: William Roske
+ * Copyright (c) 2014 Cyril Hrubis <chrubis@suse.cz>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -28,86 +31,11 @@
  * For further information regarding this notice, see:
  *
  * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
- *
  */
-/* $Id: link05.c,v 1.5 2009/10/26 14:55:47 subrata_modak Exp $ */
-/**********************************************************
- *
- *    OS Test - Silicon Graphics, Inc.
- *
- *    TEST IDENTIFIER	: link05
- *
- *    EXECUTED BY	: anyone
- *
- *    TEST TITLE	: multi links (EMLINK) negative test
- *
- *    PARENT DOCUMENT	: usctpl01
- *
- *    TEST CASE TOTAL	: 2
- *
- *    WALL CLOCK TIME	: 3
- *
- *    CPU TYPES		: ALL
- *
- *    AUTHOR		: Richard Logan
- *
- *    CO-PILOT		: William Roske
- *
- *    DATE STARTED	: 03/31/94
- *
- *    INITIAL RELEASE	: UNICOS 7.0
- *
- *    TEST CASES
- *
- * 	1.) link(2) returns...(See Description)
- *
- *    INPUT SPECIFICATIONS
- * 	The standard options for system call tests are accepted.
- *	(See the parse_opts(3) man page).
- *
- *    OUTPUT SPECIFICATIONS
- *$
- *    DURATION
- * 	Terminates - with frequency and infinite modes.
- *
- *    SIGNALS
- * 	Uses SIGUSR1 to pause before test if option set.
- * 	(See the parse_opts(3) man page).
- *
- *    RESOURCES
- * 	None
- *
- *    ENVIRONMENTAL NEEDS
- *      No run-time environmental needs.
- *
- *    SPECIAL PROCEDURAL REQUIREMENTS
- * 	None
- *
- *    INTERCASE DEPENDENCIES
- * 	None
- *
- *    DETAILED DESCRIPTION
- *	This is a Phase I test for the link(2) system call.  It is intended
- *	to provide a limited exposure of the system call, for now.  It
- *	should/will be extended when full functional tests are written for
- *	link(2).
- *
- * 	Setup:
- * 	  Setup signal handling.
- *	  Pause for SIGUSR1 if option specified.
- *
- * 	Test:
- *	 Loop if the proper options are given.
- * 	  Execute system call
- *	  Check return code, if system call failed (return=-1)
- *		Log the errno and Issue a FAIL message.
- *	  Otherwise, Issue a PASS message.
- *
- * 	Cleanup:
- * 	  Print errno log and/or timing stats if options given
- *
- *
- *#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#**/
+
+/*
+ * Test if link(2) fails with EMLINK.
+ */
 
 #include <sys/types.h>
 #include <sys/fcntl.h>
@@ -117,37 +45,28 @@
 #include <signal.h>
 #include "test.h"
 #include "usctest.h"
+#include "safe_macros.h"
 
-void setup();
-void cleanup();
-void help();
+static void setup(void);
+static void cleanup(void);
+static void help(void);
 
 char *TCID = "link05";
-#ifdef CRAY
-int TST_TOTAL = 2;
-#else
 int TST_TOTAL = 1;
-#endif
 
 #define BASENAME	"lkfile"
 
-char Basename[255];
-char Fname[255];
+static char fname[255];
 
-int Nflag = 0;
-char *Noptlinks;
+static char *links_arg;
 
-/* for test specific parse_opts options */
 option_t options[] = {
-	{"N:", &Nflag, &Noptlinks},	/* -N option */
+	{"N:", NULL, &links_arg},
 	{NULL, NULL, NULL}
 };
 
-int nlinks = 1000;
+static int nlinks = 1000;
 
-/***********************************************************************
- * Main
- ***********************************************************************/
 int main(int ac, char **av)
 {
 	int lc;
@@ -156,185 +75,91 @@ int main(int ac, char **av)
 	int cnt;
 	char lname[255];
 
-    /***************************************************************
-     * parse standard options
-     ***************************************************************/
-	if ((msg = parse_opts(ac, av, options, &help)) != NULL) {
+	if ((msg = parse_opts(ac, av, options, &help)) != NULL)
 		tst_brkm(TBROK, NULL, "OPTION PARSING ERROR - %s", msg);
-		tst_exit();
-	}
 
-	if (Nflag) {
-		if (sscanf(Noptlinks, "%i", &nlinks) != 1) {
-			tst_brkm(TBROK, cleanup,
-				 "-N option invalid, must be numeric");
+	if (links_arg) {
+		nlinks = atoi(links_arg);
+
+		if (nlinks == 0) {
+			tst_brkm(TBROK, NULL,
+			         "nlinks is not a positive number");
 		}
 	}
 
-    /***************************************************************
-     * perform global setup for test
-     ***************************************************************/
 	setup();
 
-    /***************************************************************
-     * check looping state if -c option given
-     ***************************************************************/
 	for (lc = 0; TEST_LOOPING(lc); lc++) {
 
 		tst_count = 0;
 
 		for (cnt = 1; cnt < nlinks; cnt++) {
+			sprintf(lname, "%s%d", fname, cnt);
+			TEST(link(fname, lname));
 
-			sprintf(lname, "%s%d", Basename, cnt);
-			/*
-			 *  Call link(2)
-			 */
-			TEST(link(Fname, lname));
-
-			/* check return code */
 			if (TEST_RETURN == -1) {
 				tst_resm(TFAIL,
 					 "link(%s, %s) Failed, errno=%d : %s",
-					 Fname, lname, TEST_ERRNO,
+					 fname, lname, TEST_ERRNO,
 					 strerror(TEST_ERRNO));
 			}
 		}
 
-	/***************************************************************
-	 * only perform functional verification if flag set (-f not given)
-	 ***************************************************************/
-		if (STD_FUNCTIONAL_TEST) {
-			stat(Fname, &fbuf);
+		SAFE_STAT(cleanup, fname, &fbuf);
 
-			for (cnt = 1; cnt < nlinks; cnt++) {
-				sprintf(lname, "%s%d", Basename, cnt);
+		for (cnt = 1; cnt < nlinks; cnt++) {
+			sprintf(lname, "%s%d", fname, cnt);
 
-				stat(lname, &lbuf);
-				if (fbuf.st_nlink <= 1 || lbuf.st_nlink <= 1 ||
-				    (fbuf.st_nlink != lbuf.st_nlink)) {
+			SAFE_STAT(cleanup, lname, &lbuf);
+			if (fbuf.st_nlink <= 1 || lbuf.st_nlink <= 1 ||
+			    (fbuf.st_nlink != lbuf.st_nlink)) {
 
-					tst_resm(TFAIL,
-						 "link(%s, %s[1-%d]) ret %ld for %d files, stat values do not match %d %d",
-						 Fname, Basename, nlinks,
-						 TEST_RETURN, nlinks,
-						 fbuf.st_nlink, lbuf.st_nlink);
-					break;
-				}
-			}
-			if (cnt >= nlinks) {
-				tst_resm(TPASS,
-					 "link(%s, %s[1-%d]) ret %ld for %d files, stat linkcounts match %d",
-					 Fname, Basename, nlinks, TEST_RETURN,
-					 nlinks, fbuf.st_nlink);
+				tst_resm(TFAIL,
+					 "link(%s, %s[1-%d]) ret %ld for %d "
+				         "files, stat values do not match %d %d",
+					 fname, fname, nlinks,
+					 TEST_RETURN, nlinks,
+					 (int)fbuf.st_nlink, (int)lbuf.st_nlink);
+				break;
 			}
-		} else
-			tst_count++;
-
-#ifdef CRAY
-/*
- * IRIX (xfs) systems do not have the 1000 link limit.
- * I tried 100000 links on 2/97 without error on IRIX 6.4.
- */
-		/*
-		 * Now check that one more link will put you over the top
-		 */
-		sprintf(lname, "%s%d", Basename, cnt);
-
-		/*
-		 *  Call link(2)
-		 */
-		TEST(link(Fname, lname));
-
-		/* check return code */
-		if (TEST_RETURN == -1) {
-			if (STD_FUNCTIONAL_TEST) {
-				if (TEST_ERRNO == EMLINK) {
-					tst_resm(TPASS,
-						 "link(%s, %s) ret %d on %d link, errno:%d",
-						 Fname, lname, TEST_RETURN,
-						 nlinks + 1, EMLINK);
-				} else {
-					tst_resm(TFAIL,
-						 "link(%s, %s) ret %d on %d link, errno:%d, expected -1, errno:%d",
-						 Fname, lname, TEST_RETURN,
-						 nlinks + 1, TEST_ERRNO,
-						 EMLINK);
-				}
-			} else
-				tst_count++;
-		} else {
-			tst_resm(TFAIL,
-				 "link(%s, %s) ret %d on %d link, expected -1, errno:%d",
-				 Fname, lname, TEST_RETURN, nlinks + 1, EMLINK);
 		}
-#endif /* CRAY */
+		if (cnt >= nlinks) {
+			tst_resm(TPASS,
+				 "link(%s, %s[1-%d]) ret %ld for %d files,"
+			         "stat linkcounts match %d",
+				 fname, fname, nlinks, TEST_RETURN,
+				 nlinks, (int)fbuf.st_nlink);
+		}
 
 		for (cnt = 1; cnt < nlinks; cnt++) {
-
-			sprintf(lname, "%s%d", Basename, cnt);
-
-			if (unlink(lname) == -1) {
-				tst_res(TWARN,
-					"unlink(%s) Failed, errno=%d : %s",
-					Fname, errno, strerror(errno));
-			}
+			sprintf(lname, "%s%d", fname, cnt);
+			SAFE_UNLINK(cleanup, lname);
 		}
-
 	}
 
-    /***************************************************************
-     * cleanup and exit
-     ***************************************************************/
 	cleanup();
-
 	tst_exit();
 }
 
-/***************************************************************
- * help
- ***************************************************************/
-void help()
+static void help(void)
 {
 	printf("  -N #links : create #links hard links every iteration\n");
 }
 
-/***************************************************************
- * setup() - performs all ONE TIME setup for this test.
- ***************************************************************/
-void setup()
+static void setup(void)
 {
-	int fd;
-
 	tst_sig(NOFORK, DEF_HANDLER, cleanup);
 
 	TEST_PAUSE;
 
 	tst_tmpdir();
 
-	sprintf(Fname, "%s_%d", BASENAME, getpid());
-	if ((fd = open(Fname, O_RDWR | O_CREAT, 0700)) == -1) {
-		tst_brkm(TBROK, cleanup,
-			 "open(%s, O_RDWR|O_CREAT,0700) Failed, errno=%d : %s",
-			 Fname, errno, strerror(errno));
-	} else if (close(fd) == -1) {
-		tst_res(TWARN, "close(%s) Failed, errno=%d : %s",
-			Fname, errno, strerror(errno));
-	}
-	sprintf(Basename, "%s_%d.", BASENAME, getpid());
+	sprintf(fname, "%s_%d", BASENAME, getpid());
+	SAFE_TOUCH(cleanup, fname, 0700, NULL);
 }
 
-/***************************************************************
- * cleanup() - performs all ONE TIME cleanup for this test at
- *		completion or premature exit.
- ***************************************************************/
-void cleanup()
+static void cleanup(void)
 {
-	/*
-	 * print timing stats if that option was specified.
-	 * print errno log if that option was specified.
-	 */
 	TEST_CLEANUP;
-
 	tst_rmdir();
-
 }
diff --git a/testcases/kernel/syscalls/link/link06.c b/testcases/kernel/syscalls/link/link06.c
index 6bcc737..a902b41 100644
--- a/testcases/kernel/syscalls/link/link06.c
+++ b/testcases/kernel/syscalls/link/link06.c
@@ -1,76 +1,30 @@
 /*
- *
  * Copyright (C) Bull S.A. 2001
  * Copyright (c) International Business Machines  Corp., 2001
+ * 06/2002 Ported by Jacky Malcles
+ * Copyright (c) 2014 Cyril Hrubis <chrubis@suse.cz>
  *
- *   This program is free software;  you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
+ * This program is free software;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
  *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
- *   the GNU General Public License for more details.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY;  without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
  *
- *   You should have received a copy of the GNU General Public License
- *   along with this program;  if not, write to the Free Software
- *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ * You should have received a copy of the GNU General Public License
+ * along with this program;  if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 /*
- * Test Name: link06
- *
- * Test Description:
- *  Verify that, link() fails with -1 and sets errno to EACCES when
- *	 	 Write access to the directory containing newpath is
- *		 not allowed for the process's effective uid.
- *
- * Expected Result:
- *  link() should fail with return value -1 and sets expected errno.
- *
- * Algorithm:
- *  Setup:
- *   Setup signal handling.
- *   Pause for SIGUSR1 if option specified.
- *   Create temporary directory.
- *   Modify mode permissions on temporary directory: deny write access.
- *   Create regular file.
- *   Set UID to NOBODY
- *
- *  Test:
- *   Loop if the proper options are given.
- *   Execute system call
- *   Check return code, if system call failed (return=-1)
- *   	if errno set == expected errno
- *   		Issue sys call fails with expected return value and errno.
- *   	Otherwise,
- *		Issue sys call fails with unexpected errno.
- *   Otherwise,
- *	Issue sys call returns unexpected value.
- *
- *  Cleanup:
- *   Set UID to ROOT
- *   Print errno log and/or timing stats if options given
- *   Delete the temporary directory created.
- *
- * Usage:  <for command-line>
- *  link06 [-c n] [-e] [-f] [-i n] [-I x] [-P x] [-t]
- *     where,  -c n : Run n copies concurrently.
- *             -e   : Turn on errno logging.
- *             -f   : Turn off functionality Testing.
- *	       -i n : Execute test n times.
- *	       -I x : Execute test for x seconds.
- *	       -P x : Pause for x seconds between iterations.
- *	       -t   : Turn on syscall timing.
- *
- * HISTORY
- *	06/2002 Ported by Jacky Malcles
- *
- * RESTRICTIONS:
- *  none.
- *
+ * Verify that, link() fails with -1 and sets errno to EACCES when Write access
+ * to the directory containing newpath is not allowed for the process's
+ * effective uid.
  */
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
@@ -84,151 +38,82 @@
 
 #include "test.h"
 #include "usctest.h"
+#include "safe_macros.h"
 
-#define ROOT_USER	0
 #define NOBODY_USER	99
 #define MODE_TO S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IXOTH|S_IROTH
 
-void setup();
-void cleanup();
+static void setup(void);
+static void cleanup(void);
 
 char *TCID = "link06";
 int TST_TOTAL = 1;
 
-int exp_enos[] = { EACCES, 0 };
+static int exp_enos[] = { EACCES, 0 };
 
-char *file1, *file2;		/* oldpath and newpath */
+#define OLDPATH "oldpath"
+#define NEWPATH "newpath"
 
-/***********************************************************************
- * Main
- ***********************************************************************/
 int main(int ac, char **av)
 {
 	int lc;
 	char *msg;
-	char *test_desc;	/* test specific error message */
 
-    /***************************************************************
-     * parse standard options
-     ***************************************************************/
-	if ((msg = parse_opts(ac, av, NULL, NULL)) != NULL) {
+	if ((msg = parse_opts(ac, av, NULL, NULL)) != NULL)
 		tst_brkm(TBROK, NULL, "OPTION PARSING ERROR - %s", msg);
 
-	}
-
-    /***************************************************************
-     * perform global setup for test
-     ***************************************************************/
 	setup();
 
-    /***************************************************************
-     * check looping state if -c option given
-     ***************************************************************/
 	for (lc = 0; TEST_LOOPING(lc); lc++) {
-		test_desc = "EACCES";
-
 		tst_count = 0;
 
-		/*
-		 *  Call link(2)
-		 */
-		TEST(link(file1, file2));
+		TEST(link(OLDPATH, NEWPATH));
 
-		/* Check return code from link(2) */
 		if (TEST_RETURN != -1) {
 			tst_resm(TFAIL, "link() returned %ld,"
 				 "expected -1, errno=%d", TEST_RETURN,
 				 exp_enos[0]);
 		} else {
-			TEST_ERROR_LOG(TEST_ERRNO);
-
-			if (TEST_ERRNO == exp_enos[0]) {
+			if (TEST_ERRNO == EACCES) {
 				tst_resm(TPASS, "link() fails with expected "
 					 "error EACCES errno:%d", TEST_ERRNO);
 			} else {
-				tst_resm(TFAIL, "link() fails, %s, "
+				tst_resm(TFAIL, "link() fails with "
 					 "errno=%d, expected errno=%d",
-					 test_desc, TEST_ERRNO, exp_enos[0]);
+					 TEST_ERRNO, EACCES);
 			}
 		}
 	}
 
-    /***************************************************************
-     * cleanup and exit
-     ***************************************************************/
 	cleanup();
 	tst_exit();
-
 }
 
-/***************************************************************
- * setup() - performs all ONE TIME setup for this test.
- ***************************************************************/
-void setup()
+static void setup(void)
 {
-	char Path_name[PATH_MAX];	/* Buffer to hold current path */
-	int fd;
 	struct passwd *nobody_pwd;
 
 	tst_sig(NOFORK, DEF_HANDLER, cleanup);
 
+	tst_require_root(NULL);
+
 	TEST_PAUSE;
 
 	tst_tmpdir();
-	/* Get the current working directory of the process */
-	if (getcwd(Path_name, sizeof(Path_name)) == NULL) {
-		tst_brkm(TBROK, cleanup,
-			 "getcwd(3) fails to get working directory of process");
-	}
 
 	/* Modify mode permissions on test directory */
-	if (chmod(Path_name, MODE_TO) < 0) {
-		tst_brkm(TBROK, cleanup, "chmod(2) of %s failed", Path_name);
-	}
-
-	/* create regular file */
-	if ((fd = creat("regfile", 0777)) == -1) {
-		tst_brkm(TBROK, cleanup,
-			 "creat(regfile, 0777) failed, errno:%d %s", errno,
-			 strerror(errno));
-	}
-	close(fd);
-
-	/* set paths for test */
-	file1 = "regfile";
-	file2 = "new_test_file";
-
-	if ((nobody_pwd = getpwnam("nobody")) == NULL) {
-		tst_brkm(TCONF | TERRNO, cleanup,
-			 "couldn't determine login information for nobody");
-	}
-
-	/* set effective user ID to "nobody"'s UID using seteuid */
-	if (seteuid(nobody_pwd->pw_uid) != 0) {
-		tst_brkm(TCONF | TERRNO, cleanup,
-			 "seteuid to %d for %s failed",
-			 nobody_pwd->pw_uid, nobody_pwd->pw_name);
-	}
+	SAFE_CHMOD(cleanup, ".", MODE_TO);
 
+	SAFE_TOUCH(cleanup, OLDPATH, 0777, NULL);
+	nobody_pwd = SAFE_GETPWNAM(cleanup, "nobody");
+	SAFE_SETEUID(cleanup, nobody_pwd->pw_uid);
 }
 
-/***************************************************************
- * cleanup() - performs all ONE TIME cleanup for this test at
- *		completion or premature exit.
- ***************************************************************/
-void cleanup()
+static void cleanup(void)
 {
-	/* set back effective user ID to ROOT_USER using seteuid */
-	if (seteuid(ROOT_USER) != 0) {
-		tst_resm(TFAIL | TERRNO, "seteuid to %d failed", ROOT_USER);
-	}
+	if (seteuid(0))
+		tst_resm(TWARN | TERRNO, "seteuid(0) failed");
 
-	/*
-	 * print timing stats if that option was specified.
-	 * print errno log if that option was specified.
-	 */
 	TEST_CLEANUP;
-
 	tst_rmdir();
-
 }
diff --git a/testcases/kernel/syscalls/link/link07.c b/testcases/kernel/syscalls/link/link07.c
index f5a85f0..edc92db 100644
--- a/testcases/kernel/syscalls/link/link07.c
+++ b/testcases/kernel/syscalls/link/link07.c
@@ -1,77 +1,29 @@
 /*
- *
  * Copyright (C) Bull S.A. 2001
  * Copyright (c) International Business Machines  Corp., 2001
+ *  06/2002 Ported by Jacky Malcles
+ * Copyright (c) 2014 Cyril Hrubis <chrubis@suse.cz>
  *
- *   This program is free software;  you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
+ * This program is free software;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
  *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
- *   the GNU General Public License for more details.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY;  without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
  *
- *   You should have received a copy of the GNU General Public License
- *   along with this program;  if not, write to the Free Software
- *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ * You should have received a copy of the GNU General Public License
+ * along with this program;  if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 /*
- * Test Name: link07
- *
- * Test Description:
- *  Verify that, link() fails with -1 and sets errno to EACCES when
- *	 	 one of  the  directories  in oldpath or newpath did
- *		 not allow search (execute) permission.
- *
- * Expected Result:
- *  link() should fail with return value -1 and sets expected errno.
- *
- * Algorithm:
- *  Setup:
- *   Setup signal handling.
- *   Pause for SIGUSR1 if option specified.
- *   Create temporary directory.
- *   Create a test directory and a file under it
- *   Modify mode permissions on test directory: deny execute permission.
- *   Set UID to NOBODY
- *
- *  Test:
- *   Loop if the proper options are given.
- *   Execute system call
- *   Check return code, if system call failed (return=-1)
- *   	if errno set == expected errno
- *   		Issue sys call fails with expected return value and errno.
- *   	Otherwise,
- *		Issue sys call fails with unexpected errno.
- *   Otherwise,
- *	Issue sys call returns unexpected value.
- *
- *  Cleanup:
- *   Set UID to ROOT
- *   Print errno log and/or timing stats if options given
- *   Delete the temporary directory created.
- *   Exit with return code appropriate for results.
- *
- * Usage:  <for command-line>
- *  link07 [-c n] [-e] [-f] [-i n] [-I x] [-P x] [-t]
- *     where,  -c n : Run n copies concurrently.
- *             -e   : Turn on errno logging.
- *             -f   : Turn off functionality Testing.
- *	       -i n : Execute test n times.
- *	       -I x : Execute test for x seconds.
- *	       -P x : Pause for x seconds between iterations.
- *	       -t   : Turn on syscall timing.
- *
- * HISTORY
- *	06/2002 Ported by Jacky Malcles
- *
- * RESTRICTIONS:
- *  none.
- *
+ * Verify that, link() fails with -1 and sets errno to EACCES when one of the
+ * directories in oldpath or newpath did not allow search (execute) permission.
  */
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
@@ -85,8 +37,7 @@
 
 #include "test.h"
 #include "usctest.h"
-
-#define ROOT_USER	0
+#include "safe_macros.h"
 
 #define MODE_TO S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IWGRP|S_IXGRP|S_IXOTH|S_IROTH|S_IWOTH
 #define MODE_TE S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH
@@ -95,165 +46,77 @@
 #define TEST_FILE2      "testdir_1/tfile_2"
 #define NEW_TEST_FILE2  "testdir_1/new_tfile_2"
 
-void setup();
-void cleanup();
+static void setup(void);
+static void cleanup(void);
 
 char *TCID = "link07";
 int TST_TOTAL = 1;
 
-int exp_enos[] = { EACCES, 0 };
-
-char *file1, *file2;		/* oldpath and newpath */
-
-/***********************************************************************
- * Main
- ***********************************************************************/
 int main(int ac, char **av)
 {
 	int lc;
 	char *msg;
-	char *test_desc;	/* test specific error message */
 
-    /***************************************************************
-     * parse standard options
-     ***************************************************************/
-	if ((msg = parse_opts(ac, av, NULL, NULL)) != NULL) {
+	if ((msg = parse_opts(ac, av, NULL, NULL)) != NULL)
 		tst_brkm(TBROK, NULL, "OPTION PARSING ERROR - %s", msg);
 
-	}
-
-    /***************************************************************
-     * perform global setup for test
-     ***************************************************************/
 	setup();
 
-    /***************************************************************
-     * check looping state if -c option given
-     ***************************************************************/
 	for (lc = 0; TEST_LOOPING(lc); lc++) {
-		test_desc = "EACCES";
-
 		tst_count = 0;
 
-		/*
-		 *  Call link(2)
-		 */
-		TEST(link(file1, file2));
+		TEST(link(TEST_FILE2, NEW_TEST_FILE2));
 
 		/* Check return code from link(2) */
 		if (TEST_RETURN != -1) {
-			tst_resm(TFAIL, "link() returned %ld,"
-				 "expected -1, errno=%d", TEST_RETURN,
-				 exp_enos[0]);
+			tst_resm(TFAIL | TTERRNO, "link() returned %ld,"
+				 "expected -1, errno=%d", TEST_RETURN, EACCES);
 		} else {
-			TEST_ERROR_LOG(TEST_ERRNO);
-
-			if (TEST_ERRNO == exp_enos[0]) {
-				tst_resm(TPASS, "link() fails with expected "
-					 "error EACCES errno:%d", TEST_ERRNO);
+			if (TEST_ERRNO == EACCES) {
+				tst_resm(TPASS | TTERRNO,
+				         "link() fails with expected error");
 			} else {
-				tst_resm(TFAIL, "link() fails, %s, "
-					 "errno=%d, expected errno=%d",
-					 test_desc, TEST_ERRNO, exp_enos[0]);
+				tst_resm(TFAIL | TTERRNO, "link() failed"
+				         ", expected errno=%d (EACCES)",
+				         EACCES);
 			}
 		}
 	}
 
-    /***************************************************************
-     * cleanup and exit
-     ***************************************************************/
 	cleanup();
 	tst_exit();
-
 }
 
-/***************************************************************
- * setup() - performs all ONE TIME setup for this test.
- ***************************************************************/
-void setup()
+static void setup(void)
 {
-	char Path_name[PATH_MAX];	/* Buffer to hold current path */
-	int fd;
 	struct passwd *nobody_pwd;
 
 	tst_sig(NOFORK, DEF_HANDLER, cleanup);
 
+	tst_require_root(NULL);
+
 	TEST_PAUSE;
 
 	tst_tmpdir();
-	/* Get the current working directory of the process */
-	if (getcwd(Path_name, sizeof(Path_name)) == NULL) {
-		tst_brkm(TBROK, cleanup,
-			 "getcwd(3) fails to get working directory of process");
-	}
 
 	/* Modify mode permissions on test directory */
-	if (chmod(Path_name, MODE_TO) < 0) {
-		tst_brkm(TBROK, cleanup, "chmod(2) of %s failed", Path_name);
-	}
+	SAFE_CHMOD(cleanup, ".", MODE_TO);
 
-	/* Creat a test directory and a file under it */
-	if (mkdir(DIR_TEMP, MODE_RWX) < 0) {
-		tst_brkm(TBROK, cleanup, "mkdir(2) of %s failed", DIR_TEMP);
-	}
-
-	if ((fd = open(TEST_FILE2, O_RDWR | O_CREAT, 0666)) == -1) {
-		tst_brkm(TBROK, cleanup,
-			 "open(%s, O_RDWR|O_CREAT, 0666) failed, errno=%d : %s",
-			 TEST_FILE2, errno, strerror(errno));
-	}
-
-	/* Close the testfile created above */
-	if (close(fd) == -1) {
-		tst_brkm(TBROK, cleanup,
-			 "close(%s) Failed, errno=%d : %s",
-			 TEST_FILE2, errno, strerror(errno));
-	}
+	SAFE_MKDIR(cleanup, DIR_TEMP, MODE_RWX);
+	SAFE_TOUCH(cleanup, TEST_FILE2, 0666, NULL);
 
 	/* Modify mode permissions on test directory - test conditions */
-	if (chmod(DIR_TEMP, MODE_TE) < 0) {
-		tst_brkm(TBROK, cleanup, "chmod(2) of %s failed", DIR_TEMP);
-	}
-
-	/* set paths for test */
-	file1 = TEST_FILE2;
-	file2 = NEW_TEST_FILE2;
-
-	if ((nobody_pwd = getpwnam("nobody")) == NULL) {
-		tst_brkm(TCONF | TERRNO, cleanup,
-			 "couldn't determine login information for nobody");
-	}
-
-	/* set effective user ID to "nobody"'s UID using seteuid */
-	if (seteuid(nobody_pwd->pw_uid) != 0) {
-		tst_brkm(TCONF | TERRNO, cleanup,
-			 "seteuid to %d for %s failed",
-			 nobody_pwd->pw_uid, nobody_pwd->pw_name);
-	}
+	SAFE_CHMOD(cleanup, DIR_TEMP, MODE_TE);
 
+	nobody_pwd = SAFE_GETPWNAM(cleanup, "nobody");
+	SAFE_SETEUID(cleanup, nobody_pwd->pw_uid);
 }
 
-/***************************************************************
- * cleanup() - performs all ONE TIME cleanup for this test at
- *		completion or premature exit.
- ***************************************************************/
-void cleanup()
+static void cleanup(void)
 {
-	/* set back effective user ID to ROOT_USER using seteuid */
-	if (seteuid(ROOT_USER) != 0) {
-		tst_resm(TFAIL | TERRNO, "seteuid(%d) failed", ROOT_USER);
-	}
+	if (seteuid(0))
+		tst_resm(TWARN | TERRNO, "seteuid(o) failed");
 
-	/*
-	 * print timing stats if that option was specified.
-	 * print errno log if that option was specified.
-	 */
 	TEST_CLEANUP;
-	unlink(file1);		/*Delete this tempfile created by this process */
-	unlink(file2);		/*Delete this also, empties the following directory */
-	rmdir(DIR_TEMP);	/*Now go ahead and delete this empty temp directory,
-				   this directory was chdir() from tst_tmpdir() routine in lib/tst_tmpdir.c */
-
 	tst_rmdir();
-
 }
-- 
1.8.3.2

