From 79894eeb3b050760ea002300d8ef597df65877ae Mon Sep 17 00:00:00 2001
From: Cyril Hrubis <chrubis@suse.cz>
Date: Wed, 26 Feb 2014 17:45:31 +0100
Subject: [PATCH 2/2] syscalls/swapon*: Cleanup. syscalls/swapoff*: Cleanup.
 syscalls/swapoff02: Simplify the testcase. lib: Rewrite FS type detection
 code + docs syscalls/swapon: Further cleanup. syscalls/swapon: Do not fail on
 Btrfs syscalls/swapoff: Further cleanup. syscalls/swapoff01: Do not fail on
 Btrfs

Signed-off-by: Cyril Hrubis <chrubis@suse.cz>
---
 include/swaponoff.h                             |  18 --
 include/test.h                                  |   6 -
 include/tst_fs_type.h                           |  66 +++++
 lib/tst_fs_type.c                               |  61 +++++
 lib/tst_is_cwd.c                                |  52 ----
 testcases/kernel/syscalls/fcntl/fcntl14.c       |   8 +-
 testcases/kernel/syscalls/fcntl/fcntl23.c       |   8 +-
 testcases/kernel/syscalls/fcntl/fcntl24.c       |  30 +--
 testcases/kernel/syscalls/fcntl/fcntl25.c       |  30 +--
 testcases/kernel/syscalls/fcntl/fcntl26.c       |  30 +--
 testcases/kernel/syscalls/splice/splice01.c     |   8 +-
 testcases/kernel/syscalls/swapoff/swapoff01.c   | 164 ++++--------
 testcases/kernel/syscalls/swapoff/swapoff02.c   | 244 ++++-------------
 testcases/kernel/syscalls/swapon/swapon01.c     | 150 +++--------
 testcases/kernel/syscalls/swapon/swapon02.c     | 342 ++++++------------------
 testcases/kernel/syscalls/swapon/swapon03.c     | 194 +++++---------
 testcases/kernel/syscalls/swapon/swaponoff.h    |  18 ++
 testcases/kernel/syscalls/tee/tee01.c           |   8 +-
 testcases/kernel/syscalls/utime/utime01.c       |  18 +-
 testcases/kernel/syscalls/utime/utime02.c       |  18 +-
 testcases/kernel/syscalls/utime/utime03.c       |  18 +-
 testcases/kernel/syscalls/vmsplice/vmsplice01.c |   3 +-
 22 files changed, 505 insertions(+), 989 deletions(-)
 delete mode 100644 include/swaponoff.h
 create mode 100644 include/tst_fs_type.h
 create mode 100644 lib/tst_fs_type.c
 delete mode 100644 lib/tst_is_cwd.c
 create mode 100644 testcases/kernel/syscalls/swapon/swaponoff.h

diff --git a/include/swaponoff.h b/include/swaponoff.h
deleted file mode 100644
index e3eae3f..0000000
--- a/include/swaponoff.h
+++ /dev/null
@@ -1,18 +0,0 @@
-
-#ifndef __SWAP_ON_OFF_H_
-#define __SWAP_ON_OFF_H_
-
-/*
- * Read swapon(2) / swapoff(2) for a full history lesson behind the value of
- * MAX_SWAPFILES.
- */
-#include <linux/version.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
-#define MAX_SWAPFILES 30
-#elif LINUX_VERSION_CODE > KERNEL_VERSION(2, 4, 10)
-#define MAX_SWAPFILES 32
-#else
-#define MAX_SWAPFILES 8
-#endif
-
-#endif
diff --git a/include/test.h b/include/test.h
index 7087ac3..5156a78 100644
--- a/include/test.h
+++ b/include/test.h
@@ -183,12 +183,6 @@ struct tst_kern_exv {
 
 int tst_kvercmp2(int r1, int r2, int r3, struct tst_kern_exv *vers);
 
-/* lib/tst_is_cwd.c */
-int tst_is_cwd_nfs(void);
-int tst_is_cwd_v9fs(void);
-int tst_is_cwd_tmpfs(void);
-int tst_is_cwd_ramfs(void);
-
 /* lib/tst_cwd_has_free.c */
 int tst_cwd_has_free(int required_kib);
 
diff --git a/include/tst_fs_type.h b/include/tst_fs_type.h
new file mode 100644
index 0000000..92b7120
--- /dev/null
+++ b/include/tst_fs_type.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2014 Linux Test Project
+ * Cyril Hrubis <chrubis@suse.cz>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it would be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * Further, this software is distributed without any warranty that it is
+ * free of the rightful claim of any third person regarding infringement
+ * or the like.  Any license provided herein, whether implied or
+ * otherwise, applies only to this software file.  Patent licenses, if
+ * any, provided herein do not apply to combinations of this program with
+ * other software, or any other product whatsoever.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __TST_FS_TYPE_H__
+#define __TST_FS_TYPE_H__
+
+/* man 2 statfs or kernel-source/include/linux/magic.h */
+
+#define TST_BTRFS_MAGIC 0x9123683E
+#define TST_NFS_MAGIC   0x6969
+#define TST_RAMFS_MAGIC 0x858458f6
+#define TST_TMPFS_MAGIC 0x01021994
+#define TST_V9FS_MAGIC  0x01021997
+
+/*
+ * Returns filesystem magick for a given path.
+ *
+ * The expected usage is:
+ *
+ *      if (tst_fs_type(cleanup, ".") == TST_NFS_MAGIC) {
+ *		tst_brkm(TCONF, cleanup,
+ *		         "Test not supported on NFS filesystem");
+ *	}
+ *
+ * Or:
+ *
+ *	long type;
+ *
+ *	swtich ((type = tst_fs_type(cleanup, "."))) {
+ *	case TST_NFS_MAGIC:
+ *	case TST_TMPFS_MAGIC:
+ *	case TST_RAMFS_MAGIC:
+ *		tst_brkm(TCONF, cleanup, "Test not supported on %s filesystem",
+ *		         tst_fs_type_name(type));
+ *	break;
+ *	}
+ */
+long tst_fs_type(void (*cleanup)(void), const char *path);
+
+/*
+ * Returns filesystem name given magic.
+ */
+const char *tst_fs_type_name(long f_type);
+
+#endif	/* __TST_FS_TYPE_H__ */
diff --git a/lib/tst_fs_type.c b/lib/tst_fs_type.c
new file mode 100644
index 0000000..4805bac
--- /dev/null
+++ b/lib/tst_fs_type.c
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2005-2014 Linux Test Project
+ *
+ * Cyril Hrubis <chrubis@suse.cz> 2014
+ * Michal Simek <monstr@monstr.eu> 2009
+ * Kumar Gala <galak@kernel.crashing.org> 2007
+ * Ricky Ng-Adam <rngadam@yahoo.com> 2005
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it would be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * Further, this software is distributed without any warranty that it is
+ * free of the rightful claim of any third person regarding infringement
+ * or the like.  Any license provided herein, whether implied or
+ * otherwise, applies only to this software file.  Patent licenses, if
+ * any, provided herein do not apply to combinations of this program with
+ * other software, or any other product whatsoever.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <sys/vfs.h>
+#include "test.h"
+#include "tst_fs_type.h"
+
+long tst_fs_type(void (*cleanup)(void), const char *path)
+{
+	struct statfs sbuf;
+
+	if (statfs(path, &sbuf)) {
+		tst_brkm(TBROK | TERRNO, cleanup,
+		         "tst_fs_type: Failed to statfs(%s)", path);
+	}
+
+	return sbuf.f_type;
+}
+
+const char *tst_fs_type_name(long f_type)
+{
+	switch (f_type) {
+	case TST_TMPFS_MAGIC:
+		return "TMPFS";
+	case TST_NFS_MAGIC:
+		return "NFS";
+	case TST_V9FS_MAGIC:
+		return "9P";
+	case TST_RAMFS_MAGIC:
+		return "RAMFS";
+	case TST_BTRFS_MAGIC:
+		return "BTRFS";
+	default:
+		return "Unknown";
+	}
+}
diff --git a/lib/tst_is_cwd.c b/lib/tst_is_cwd.c
deleted file mode 100644
index 1021660..0000000
--- a/lib/tst_is_cwd.c
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Michal Simek <monstr@monstr.eu>, 2009-08-03 - ramfs
- * Kumar Gala <galak@kernel.crashing.org>, 2007-11-14 - nfs
- * Ricky Ng-Adam <rngadam@yahoo.com>, 2005-01-01 - tmpfs
- *
- * DESCRIPTION
- *	Check if current directory is on a tmpfs/nfs/ramfs filesystem
- *	If current directory is tmpfs/nfs/ramfs, return 1
- *	If current directory is NOT tmpfs/nfs/ramfs, return 0
- */
-
-#include <sys/vfs.h>
-
-#define TMPFS_MAGIC 0x01021994	/* man 2 statfs */
-int tst_is_cwd_tmpfs(void)
-{
-	struct statfs sf;
-	statfs(".", &sf);
-
-	/* Verify that the file is not on a tmpfs (in-memory) filesystem */
-	return (sf.f_type == TMPFS_MAGIC);
-}
-
-#define NFS_MAGIC 0x6969	/* man 2 statfs */
-int tst_is_cwd_nfs(void)
-{
-	struct statfs sf;
-	statfs(".", &sf);
-
-	/* Verify that the file is not on a nfs filesystem */
-	return (sf.f_type == NFS_MAGIC);
-}
-
-#define V9FS_MAGIC 0x01021997	/* kernel-source/include/linux/magic.h */
-int tst_is_cwd_v9fs(void)
-{
-	struct statfs sf;
-	statfs(".", &sf);
-
-	/*  Verify that the file is not on a nfs filesystem */
-	return (sf.f_type == V9FS_MAGIC);
-}
-
-#define RAMFS_MAGIC 0x858458f6
-int tst_is_cwd_ramfs(void)
-{
-	struct statfs sf;
-	statfs(".", &sf);
-
-	/* Verify that the file is not on a ramfs (in-memory) filesystem */
-	return (sf.f_type == RAMFS_MAGIC);
-}
diff --git a/testcases/kernel/syscalls/fcntl/fcntl14.c b/testcases/kernel/syscalls/fcntl/fcntl14.c
index e7d54b4..c1ea200 100644
--- a/testcases/kernel/syscalls/fcntl/fcntl14.c
+++ b/testcases/kernel/syscalls/fcntl/fcntl14.c
@@ -49,6 +49,7 @@
 #include <inttypes.h>
 #include "usctest.h"
 #include "test.h"
+#include "tst_fs_type.h"
 
 #define SKIP 0x0c00
 #if SKIP == F_RDLCK || SKIP== F_WRLCK
@@ -990,12 +991,9 @@ int main(int ac, char **av)
 
 	setup();		/* global setup */
 
-	/*
-	 * check if the current filesystem is nfs
-	 */
-	if (tst_is_cwd_nfs()) {
+	if (tst_fs_type(cleanup, ".") == TST_NFS_MAGIC) {
 		tst_brkm(TCONF, cleanup,
-			 "Cannot do fcntl on a file located on an NFS filesystem");
+			 "Cannot do fcntl on a file on NFS filesystem");
 	}
 
 	/* Check for looping state if -i option is given */
diff --git a/testcases/kernel/syscalls/fcntl/fcntl23.c b/testcases/kernel/syscalls/fcntl/fcntl23.c
index 3e24244..e70ab52 100644
--- a/testcases/kernel/syscalls/fcntl/fcntl23.c
+++ b/testcases/kernel/syscalls/fcntl/fcntl23.c
@@ -94,6 +94,7 @@
 #include <signal.h>
 #include "test.h"
 #include "usctest.h"
+#include "tst_fs_type.h"
 
 void setup();
 void cleanup();
@@ -122,12 +123,9 @@ int main(int ac, char **av)
      ***************************************************************/
 	setup();
 
-	/*
-	 * check if the current filesystem is nfs
-	 */
-	if (tst_is_cwd_nfs()) {
+	if (tst_fs_type(cleanup, ".") == TST_NFS_MAGIC) {
 		tst_brkm(TCONF, cleanup,
-			 "Cannot do fcntl on a file located on an NFS filesystem");
+			 "Cannot do fcntl on a file on NFS filesystem");
 	}
 
 	/* set the expected errnos... */
diff --git a/testcases/kernel/syscalls/fcntl/fcntl24.c b/testcases/kernel/syscalls/fcntl/fcntl24.c
index b2d1662..c40d731 100644
--- a/testcases/kernel/syscalls/fcntl/fcntl24.c
+++ b/testcases/kernel/syscalls/fcntl/fcntl24.c
@@ -94,6 +94,7 @@
 #include <signal.h>
 #include "test.h"
 #include "usctest.h"
+#include "tst_fs_type.h"
 
 void setup();
 void cleanup();
@@ -109,6 +110,7 @@ int fd;
 int main(int ac, char **av)
 {
 	int lc;
+	long type;
 	char *msg;
 
     /***************************************************************
@@ -122,28 +124,14 @@ int main(int ac, char **av)
      ***************************************************************/
 	setup();
 
-	/*
-	 * check if the current filesystem is nfs
-	 */
-	if (tst_is_cwd_nfs()) {
-		tst_brkm(TCONF, cleanup,
-			 "Cannot do fcntl on a file located on an NFS filesystem");
-	}
-
-	/*
-	 * check if the current filesystem is tmpfs
-	 */
-	if (tst_is_cwd_tmpfs()) {
-		tst_brkm(TCONF, cleanup,
-			 "Cannot do fcntl on a file located on an TMPFS filesystem");
-	}
-
-	/*
-	 * check if the current filesystem is ramfs
-	 */
-	if (tst_is_cwd_ramfs()) {
+	switch ((type = tst_fs_type(cleanup, "."))) {
+	case TST_NFS_MAGIC:
+	case TST_RAMFS_MAGIC:
+	case TST_TMPFS_MAGIC:
 		tst_brkm(TCONF, cleanup,
-			 "Cannot do fcntl on a file located on an RAMFS filesystem");
+			 "Cannot do fcntl on a file on %s filesystem",
+			 tst_fs_type_name(type));
+	break;
 	}
 
 	/* set the expected errnos... */
diff --git a/testcases/kernel/syscalls/fcntl/fcntl25.c b/testcases/kernel/syscalls/fcntl/fcntl25.c
index 80b8a90..e65b54c 100644
--- a/testcases/kernel/syscalls/fcntl/fcntl25.c
+++ b/testcases/kernel/syscalls/fcntl/fcntl25.c
@@ -95,6 +95,7 @@
 #include <signal.h>
 #include "test.h"
 #include "usctest.h"
+#include "tst_fs_type.h"
 
 void setup();
 void cleanup();
@@ -110,6 +111,7 @@ int fd;
 int main(int ac, char **av)
 {
 	int lc;
+	long type;
 	char *msg;
 
     /***************************************************************
@@ -123,28 +125,14 @@ int main(int ac, char **av)
      ***************************************************************/
 	setup();
 
-	/*
-	 * check if the current filesystem is nfs
-	 */
-	if (tst_is_cwd_nfs()) {
-		tst_brkm(TCONF, cleanup,
-			 "Cannot do fcntl on a file located on an NFS filesystem");
-	}
-
-	/*
-	 * check if the current filesystem is tmpfs
-	 */
-	if (tst_is_cwd_tmpfs()) {
-		tst_brkm(TCONF, cleanup,
-			 "Cannot do fcntl on a file located on an TMPFS filesystem");
-	}
-
-	/*
-	 * check if the current filesystem is ramfs
-	 */
-	if (tst_is_cwd_ramfs()) {
+	switch ((type = tst_fs_type(cleanup, "."))) {
+	case TST_NFS_MAGIC:
+	case TST_RAMFS_MAGIC:
+	case TST_TMPFS_MAGIC:
 		tst_brkm(TCONF, cleanup,
-			 "Cannot do fcntl on a file located on an RAMFS filesystem");
+			 "Cannot do fcntl on a file on %s filesystem",
+			 tst_fs_type_name(type));
+	break;
 	}
 
 	/* set the expected errnos... */
diff --git a/testcases/kernel/syscalls/fcntl/fcntl26.c b/testcases/kernel/syscalls/fcntl/fcntl26.c
index e78ee6f..3f3fb34 100644
--- a/testcases/kernel/syscalls/fcntl/fcntl26.c
+++ b/testcases/kernel/syscalls/fcntl/fcntl26.c
@@ -95,6 +95,7 @@
 #include <signal.h>
 #include "test.h"
 #include "usctest.h"
+#include "tst_fs_type.h"
 
 void setup();
 void cleanup();
@@ -110,6 +111,7 @@ int fd;
 int main(int ac, char **av)
 {
 	int lc;
+	long type;
 	char *msg;
 
     /***************************************************************
@@ -123,28 +125,14 @@ int main(int ac, char **av)
      ***************************************************************/
 	setup();
 
-	/*
-	 * check if the current filesystem is nfs
-	 */
-	if (tst_is_cwd_nfs()) {
-		tst_brkm(TCONF, cleanup,
-			 "Cannot do fcntl on a file located on an NFS filesystem");
-	}
-
-	/*
-	 * check if the current filesystem is tmpfs
-	 */
-	if (tst_is_cwd_tmpfs()) {
-		tst_brkm(TCONF, cleanup,
-			 "Cannot do fcntl on a file located on an TMPFS filesystem");
-	}
-
-	/*
-	 * check if the current filesystem is ramfs
-	 */
-	if (tst_is_cwd_ramfs()) {
+	switch ((type = tst_fs_type(cleanup, "."))) {
+	case TST_NFS_MAGIC:
+	case TST_RAMFS_MAGIC:
+	case TST_TMPFS_MAGIC:
 		tst_brkm(TCONF, cleanup,
-			 "Cannot do fcntl on a file located on an RAMFS filesystem");
+			 "Cannot do fcntl on a file on %s filesystem",
+			 tst_fs_type_name(type));
+	break;
 	}
 
 	/* set the expected errnos... */
diff --git a/testcases/kernel/syscalls/splice/splice01.c b/testcases/kernel/syscalls/splice/splice01.c
index 782be18..593c687 100644
--- a/testcases/kernel/syscalls/splice/splice01.c
+++ b/testcases/kernel/syscalls/splice/splice01.c
@@ -51,6 +51,7 @@
 #include "test.h"
 #include "usctest.h"
 #include "linux_syscall_numbers.h"
+#include "tst_fs_type.h"
 
 #define SPLICE_TEST_BLOCK_SIZE 1024
 
@@ -95,13 +96,10 @@ int main(int ac, char **av)
 	 */
 	setup();
 
-	/*
-	 * check if the current filesystem of the test directory is nfs
-	 */
 	tst_tmpdir();
-	if (tst_is_cwd_nfs()) {
+	if (tst_fs_type(cleanup, ".") == TST_NFS_MAGIC) {
 		tst_brkm(TCONF, cleanup,
-			 "Cannot do splice on a file located on an NFS filesystem");
+			 "Cannot do splice on a file on NFS filesystem");
 	}
 	tst_rmdir();
 
diff --git a/testcases/kernel/syscalls/swapoff/swapoff01.c b/testcases/kernel/syscalls/swapoff/swapoff01.c
index 78fb65e..b4d19de 100644
--- a/testcases/kernel/syscalls/swapoff/swapoff01.c
+++ b/testcases/kernel/syscalls/swapoff/swapoff01.c
@@ -14,65 +14,10 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
  */
-/**************************************************************************
- *
- *    TEST IDENTIFIER	: swapoff01
- *
- *    EXECUTED BY	: root / superuser
- *
- *    TEST TITLE	: Basic test for swapoff(2)
- *
- *    TEST CASE TOTAL	: 1
- *
- *    AUTHOR		: Aniruddha Marathe <aniruddha.marathe@wipro.com>
- *
- *    SIGNALS
- * 	Uses SIGUSR1 to pause before test if option set.
- * 	(See the parse_opts(3) man page).
- *
- *    DESCRIPTION
- *    This is a Phase I test for the swapoff(2) system call.
- *    It is intended to provide a limited exposure of the system call.
- *   $
- *
- * 	Setup:
- *	  Setup signal handling.
- *	  Pause for SIGUSR1 if option specified.
- *	  Create a temporary directory.
- *	  Create file of size 40K ( minimum swapfile size).
- *	  Make this file as swap file using mkswap(8)
- *	  Turn on the swap file.
- *
- * 	Test:
- *	 Loop if the proper options are given.
- *	  Execute system call
- *	  Check return code, if system call failed (return=-1)
- *		Log the errno and Issue a FAIL message.
- *	  Otherwise, Issue a PASS message.
- *
- * 	Cleanup:
- * 	  Print errno log and/or timing stats if options given
- *
- * USAGE:  <for command-line>
- * swapoff01 [-c n] [-e] [-i n] [-I x] [-P x] [-t] [-h] [-f] [-p]
- * where:
- * 	-c n : Run n copies simultaneously.
- *	-e   : Turn on errno logging.
- *	-i n : Execute test n times.
- *	-I x : Execute test for x seconds.
- *	-p   : Pause for SIGUSR1 before starting
- *	-P x : Pause for x seconds between iterations.
- *	-t   : Turn on syscall timing.
- *
- *RESTRICTIONS:
- * Not compatible with kernel versions below 1.3.2.
- *
- *CHANGES:
- * 2005/01/01  Add extra check to stop test if insufficient disk space in dir
- *             -Ricky Ng-Adam (rngadam@yahoo.com)
- * 2005/01/01  Add extra check to stop test if swap file is on tmpfs
- *             -Ricky Ng-Adam (rngadam@yahoo.com)
- *****************************************************************************/
+
+/*
+ * Check that swapoff() succeeds.
+ */
 
 #include <unistd.h>
 #include "test.h"
@@ -81,17 +26,19 @@
 #include <stdlib.h>
 #include "config.h"
 #include "linux_syscall_numbers.h"
-#include "swaponoff.h"
+#include "tst_fs_type.h"
 
-static void setup();
-static void cleanup();
+static void setup(void);
+static void cleanup(void);
+static void verify_swapoff(void);
 
 char *TCID = "swapoff01";
 int TST_TOTAL = 1;
 
+static long fs_type;
+
 int main(int ac, char **av)
 {
-
 	int lc;
 	char *msg;
 
@@ -101,60 +48,55 @@ int main(int ac, char **av)
 	setup();
 
 	for (lc = 0; TEST_LOOPING(lc); lc++) {
-
 		tst_count = 0;
+		verify_swapoff();
+	}
 
-		if (ltp_syscall(__NR_swapon, "./swapfile01", 0) != 0) {
-			tst_resm(TWARN, "Failed to turn on the swap file"
-				 ", skipping test iteration");
-			continue;
-		}
+	cleanup();
+	tst_exit();
+}
 
-		TEST(ltp_syscall(__NR_swapoff, "./swapfile01"));
-
-		/* check return code */
-		if (TEST_RETURN == -1) {
-			TEST_ERROR_LOG(TEST_ERRNO);
-			tst_resm(TFAIL, "swapoff(2) Failed to turn off"
-				 " swapfile. System reboot after execution"
-				 " of LTP test suite is recommended.");
-			tst_resm(TWARN, "It is recommended not to run"
-				 " swapon01 and swapon02");
-		} else {
-			tst_resm(TPASS, "swapoff(2) passed and turned off"
-				 " swapfile.");
+static void verify_swapoff(void)
+{
+	if (ltp_syscall(__NR_swapon, "./swapfile01", 0) != 0) {
+		if (fs_type == TST_BTRFS_MAGIC && errno == EINVAL) {
+			tst_brkm(TCONF, cleanup,
+			         "Swapfiles on BTRFS are not implemented");
 		}
-	}			/*End for TEST_LOOPING */
 
-	/*Clean up and exit */
-	cleanup();
-	tst_exit();
+		tst_resm(TBROK, "Failed to turn on the swap file"
+			 ", skipping test iteration");
+		return;
+	}
+
+	TEST(ltp_syscall(__NR_swapoff, "./swapfile01"));
 
+	if (TEST_RETURN == -1) {
+		tst_resm(TFAIL | TTERRNO, "Failed to turn off swapfile,"
+		         " system reboot after execution of LTP "
+			 "test suite is recommended.");
+	} else {
+		tst_resm(TPASS, "Succeeded to turn off swapfile");
+	}
 }
 
-/* setup() - performs all ONE TIME setup for this test */
-void setup()
+static void setup(void)
 {
-
 	tst_sig(FORK, DEF_HANDLER, cleanup);
 
-	/* Check whether we are root */
-	if (geteuid() != 0) {
-		tst_brkm(TBROK, NULL, "Test must be run as root");
-	}
+	tst_require_root(NULL);
 
 	TEST_PAUSE;
 
 	tst_tmpdir();
 
-	if (tst_is_cwd_tmpfs()) {
+	switch ((fs_type = tst_fs_type(cleanup, "."))) {
+	case TST_NFS_MAGIC:
+	case TST_TMPFS_MAGIC:
 		tst_brkm(TCONF, cleanup,
-			 "Cannot do swapon on a file located on a tmpfs filesystem");
-	}
-
-	if (tst_is_cwd_nfs()) {
-		tst_brkm(TCONF, cleanup,
-			 "Cannot do swapon on a file located on a nfs filesystem");
+			 "Cannot do swapoff on a file on %s filesystem",
+			 tst_fs_type_name(fs_type));
+	break;
 	}
 
 	if (!tst_cwd_has_free(65536)) {
@@ -162,32 +104,16 @@ void setup()
 			 "Insufficient disk space to create swap file");
 	}
 
-	/*create file */
-	if (system
-	    ("dd if=/dev/zero of=swapfile01 bs=1024  count=65536 > tmpfile"
-	     " 2>&1 ") != 0) {
+	if (tst_fill_file("swapfile01", 0x00, 1024, 65536))
 		tst_brkm(TBROK, cleanup, "Failed to create file for swap");
-	}
 
-	/* make above file a swap file */
-	if (system("mkswap swapfile01 > tmpfile 2>&1") != 0) {
+	if (system("mkswap swapfile01 > tmpfile 2>&1") != 0)
 		tst_brkm(TBROK, cleanup, "Failed to make swapfile");
-	}
-
 }
 
-/*
- * cleanup() - Performs one time cleanup for this test at
- * completion or premature exit
- */
-void cleanup()
+static void cleanup(void)
 {
-	/*
-	 * print timing stats if that option was specified.
-	 * print errno log if that option was specified.
-	 */
 	TEST_CLEANUP;
 
 	tst_rmdir();
-
 }
diff --git a/testcases/kernel/syscalls/swapoff/swapoff02.c b/testcases/kernel/syscalls/swapoff/swapoff02.c
index 633bf26..978dc01 100644
--- a/testcases/kernel/syscalls/swapoff/swapoff02.c
+++ b/testcases/kernel/syscalls/swapoff/swapoff02.c
@@ -14,66 +14,13 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
  */
-/**************************************************************************
- *
- *    TEST IDENTIFIER	: swapoff02
- *
- *
- *    EXECUTED BY	: root / superuser
- *
- *    TEST TITLE	: Test checking for basic error conditions
- *    				 for swapoff(2)
- *
- *    TEST CASE TOTAL	: 3
- *
- *    AUTHOR		: Aniruddha Marathe <aniruddha.marathe@wipro.com>
- *
- *    SIGNALS
- * 	Uses SIGUSR1 to pause before test if option set.
- * 	(See the parse_opts(3) man page).
- *
- *    DESCRIPTION
- *	This test case checks whether swapoff(2) system call  returns
- *	1. EINVAL when the path does not exist
- *	2. ENOENT when the path exists but is invalid
- *	3. EPERM when user is not a superuser
- *
- * 	Setup:
- *	  Setup signal handling.
- *	  Pause for SIGUSR1 if option specified.
- *	 1.  For testing error on invalid user, change the effective uid
- * 	$
- * 	Test:
- *	  Loop if the proper options are given.
- *	  Execute system call.
- *	  Check return code, if system call fails with errno == expected errno
- *		Issue syscall passed with expected errno
- *	  Otherwise,
- *	  Issue syscall failed to produce expected errno
- *
- * 	Cleanup:
- * 	  Do cleanup for the test.
- * 	 $
- * USAGE:  <for command-line>
- *  swapoff02 [-c n] [-e] [-i n] [-I x] [-p x] [-t] [-h] [-f] [-p]
- *  where
- *  	-c n : Run n copies simultaneously
- *	-e   : Turn on errno logging.
- *	-i n : Execute test n times.
- *	-I x : Execute test for x seconds.
- *	-p   : Pause for SIGUSR1 before starting
- *	-P x : Pause for x seconds between iterations.
- *	-t   : Turn on syscall timing.
- *
- *RESTRICTIONS:
- *Incompatible with kernel versions below 2.1.35.
- *
- *CHANGES:
- * 2005/01/01  Add extra check to stop test if insufficient disk space in dir
- *             -Ricky Ng-Adam (rngadam@yahoo.com)
- * 2005/01/01  Add extra check to stop test if swap file is on tmpfs
- *             -Ricky Ng-Adam (rngadam@yahoo.com)
- *****************************************************************************/
+
+/*
+ * This test case checks whether swapoff(2) system call  returns
+ *  1. EINVAL when the path does not exist
+ *  2. ENOENT when the path exists but is invalid
+ *  3. EPERM when user is not a superuser
+ */
 
 #include <unistd.h>
 #include <errno.h>
@@ -82,45 +29,40 @@
 #include <fcntl.h>
 #include <pwd.h>
 #include <string.h>
+#include <stdlib.h>
 #include "test.h"
 #include "usctest.h"
-#include <stdlib.h>
-#include "config.h"
 #include "linux_syscall_numbers.h"
-#include "swaponoff.h"
+#include "safe_macros.h"
+#include "tst_fs_type.h"
 
-static void setup();
-static void cleanup();
-static int setup01();
-static int cleanup01();
-static int setup02();
+static void setup(void);
+static void cleanup(void);
+static int setup01(void);
+static void cleanup01(void);
 
 char *TCID = "swapoff02";
 int TST_TOTAL = 3;
-char nobody_uid[] = "nobody";
-struct passwd *ltpuser;
-int need_swapfile_cleanup = 0;	/* attempt to swapoff in cleanup */
+
+static uid_t nobody_uid;
 
 static int exp_enos[] = { EPERM, EINVAL, ENOENT, 0 };
 
 static struct test_case_t {
-	char *err_desc;		/* error description */
-	int exp_errno;		/* expected error number */
-	char *exp_errval;	/* Expected errorvalue string */
-	char *path;		/* path for swapon */
-	int (*setupfunc) ();	/* Test setup function */
-	int (*cleanfunc) ();	/* Test cleanup function */
+	char *err_desc;
+	int exp_errno;
+	char *exp_errval;
+	char *path;
+	int (*setup)(void);
+	void (*cleanup)(void);
 } testcase[] = {
-	{
-	"path does not exist", ENOENT, "ENOENT", "./abcd", NULL, NULL}, {
-	"Invalid path", EINVAL, "EINVAL ", "./nofile", setup02, NULL}, {
-	"Permission denied", EPERM, "EPERM ", "./swapfile01",
-		    setup01, cleanup01}
+	{"path does not exist", ENOENT, "ENOENT", "./doesnotexist", NULL, NULL},
+	{"Invalid file", EINVAL, "EINVAL", "./swapfile01", NULL, NULL},
+	{"Permission denied", EPERM, "EPERM", "./swapfile01", setup01, cleanup01}
 };
 
 int main(int ac, char **av)
 {
-
 	int lc, i;
 	char *msg;
 
@@ -135,24 +77,15 @@ int main(int ac, char **av)
 
 		for (i = 0; i < TST_TOTAL; i++) {
 
-			if (testcase[i].setupfunc &&
-			    testcase[i].setupfunc() == -1) {
-				tst_resm(TWARN, "Failed to setup test %d."
-					 " Skipping test", i);
-				continue;
-			} else {
-				TEST(ltp_syscall(__NR_swapoff,
-					testcase[i].path));
-			}
+			if (testcase[i].setup)
+				testcase[i].setup();
 
-			if (testcase[i].cleanfunc &&
-			    testcase[i].cleanfunc() == -1) {
-				tst_brkm(TBROK, cleanup, "cleanup failed,"
-					 " quitting the test");
-			}
+			TEST(ltp_syscall(__NR_swapoff, testcase[i].path));
+
+			if (testcase[i].cleanup)
+				testcase[i].cleanup();
 
-			/* check return code */
-			if ((TEST_RETURN == -1)
+			if (TEST_RETURN == -1
 			    && (TEST_ERRNO == testcase[i].exp_errno)) {
 				tst_resm(TPASS,
 					 "swapoff(2) expected failure;"
@@ -179,132 +112,63 @@ int main(int ac, char **av)
 			}
 
 			TEST_ERROR_LOG(TEST_ERRNO);
-		}		/*End of TEST LOOPS */
+		}
 	}
 
-	/*Clean up and exit */
 	cleanup();
-
 	tst_exit();
-}				/*End of main */
-
-/*
- * setup01() - This function sets the user as nobody
- */
-int setup01()
-{
-	if ((ltpuser = getpwnam(nobody_uid)) == NULL) {
-		tst_resm(TWARN, "\"nobody\" user not present. skipping test");
-		return -1;
-	}
-
-	if (seteuid(ltpuser->pw_uid) == -1) {
-		tst_resm(TWARN, "seteuid failed to "
-			 "to set the effective uid to %d", ltpuser->pw_uid);
-		perror("seteuid");
-		return -1;
-	}
-
-	return 0;		/* user switched to nobody */
 }
 
-/*
- * cleanup01() - switch back to user root
- */
-int cleanup01()
+static int setup01(void)
 {
-	if (seteuid(0) == -1) {
-		tst_brkm(TBROK, cleanup, "seteuid failed to set uid to root");
-		perror("seteuid");
-		return -1;
-	}
-
+	SAFE_SETEUID(cleanup, nobody_uid);
 	return 0;
 }
 
-int setup02()
+static void cleanup01(void)
 {
-	int fd;
-	fd = creat("nofile", S_IRWXU);
-	if (fd == -1)
-		tst_resm(TWARN, "Failed to create temporary file");
-	return 0;
+	SAFE_SETEUID(cleanup, 0);
 }
 
-/* setup() - performs all ONE TIME setup for this test */
-void setup()
+static void setup(void)
 {
+	long type;
+	struct passwd *nobody;
 
 	tst_sig(FORK, DEF_HANDLER, cleanup);
 
-	/* set the expected errnos... */
 	TEST_EXP_ENOS(exp_enos);
 
-	/* Check whether we are root */
-	if (geteuid() != 0) {
-		tst_brkm(TBROK, NULL, "Test must be run as root");
-	}
+	tst_require_root(NULL);
+
+	nobody = SAFE_GETPWNAM(NULL, "nobody");
+	nobody_uid = nobody->pw_uid;
 
 	TEST_PAUSE;
 
 	tst_tmpdir();
 
-	if (tst_is_cwd_tmpfs()) {
-		tst_brkm(TCONF, cleanup,
-			 "Cannot do swapon on a file located on a tmpfs filesystem");
-	}
-
-	if (tst_is_cwd_nfs()) {
+	switch ((type = tst_fs_type(cleanup, "."))) {
+	case TST_NFS_MAGIC:
+	case TST_TMPFS_MAGIC:
 		tst_brkm(TCONF, cleanup,
-			 "Cannot do swapon on a file located on a nfs filesystem");
+			 "Cannot do swapoff on a file on %s filesystem",
+			 tst_fs_type_name(type));
+	break;
 	}
 
-	if (!tst_cwd_has_free(65536)) {
+	if (!tst_cwd_has_free(1)) {
 		tst_brkm(TBROK, cleanup,
 			 "Insufficient disk space to create swap file");
 	}
 
-	/*create file */
-	if (system
-	    ("dd if=/dev/zero of=swapfile01 bs=1024  count=65536 > tmpfile"
-	     " 2>&1") != 0) {
-		tst_brkm(TBROK, cleanup, "Failed to create file for swap");
-	}
-
-	/* make above file a swap file */
-	if (system("mkswap ./swapfile01 > tmpfile 2>&1") != 0) {
-		tst_brkm(TBROK, cleanup, "Failed to make swapfile");
-	}
-
-	if (ltp_syscall(__NR_swapon, "./swapfile01", 0) != 0) {
-		tst_brkm(TBROK, cleanup, "Failed to turn on the swap file."
-			 " skipping  the test iteration");
-	}
-
-	need_swapfile_cleanup = 1;
-
+	if (tst_fill_file("./swapfile01", 0x00, 1024, 1))
+		tst_brkm(TBROK, cleanup, "Failed to create swapfile");
 }
 
-/*
-* cleanup() - Performs one time cleanup for this test at
-* completion or premature exit
-*/
-void cleanup()
+static void cleanup(void)
 {
-	/*
-	 * print timing stats if that option was specified.
-	 * print errno log if that option was specified.
-	 */
 	TEST_CLEANUP;
 
-	if (need_swapfile_cleanup
-	    && (ltp_syscall(__NR_swapoff, "./swapfile01") != 0)) {
-		tst_resm(TWARN,
-			 " Failed to turn off swap file. System reboot"
-			 " after execution of LTP test suite is"
-			 " recommended.");
-	}
-
 	tst_rmdir();
-
 }
diff --git a/testcases/kernel/syscalls/swapon/swapon01.c b/testcases/kernel/syscalls/swapon/swapon01.c
index feefc58..96619d0 100644
--- a/testcases/kernel/syscalls/swapon/swapon01.c
+++ b/testcases/kernel/syscalls/swapon/swapon01.c
@@ -14,81 +14,50 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
  */
-/**************************************************************************
- *
- *    TEST IDENTIFIER	: swapon1
- *
- *    EXECUTED BY	: root / superuser
- *
- *    TEST TITLE	: Basic test for swapon(2)
- *
- *    TEST CASE TOTAL	: 1
- *
- *    AUTHOR		: Aniruddha Marathe <aniruddha.marathe@wipro.com>
- *
- *    SIGNALS
- * 	Uses SIGUSR1 to pause before test if option set.
- * 	(See the parse_opts(3) man page).
- *
- *    DESCRIPTION
- *    This is a Phase I test for the swapon(2) system call.
- *    It is intended to provide a limited exposure of the system call.
- *
- * 	Setup:
- *	  Setup signal handling.
- *	  Pause for SIGUSR1 if option specified.
- *	  Create a temporary directory.
- *	  Create file of size 32Mb .
- *	  Make this file as swap file using mkswap(8)
- *
- * 	Test:
- *	 Loop if the proper options are given.
- *	 Turn on the swapfile to test the system call
- *	  Execute system call
- *	  Check return code, if system call failed (return=-1)
- *		Log the errno and Issue a FAIL message.
- *	  Otherwise, Issue a PASS message.
- *
- * 	Cleanup:
- * 	  Print errno log and/or timing stats if options given
- *
- * USAGE:  <for command-line>
- * swapon01 [-c n] [-e] [-i n] [-I x] [-P x] [-t] [-h] [-f] [-p]
- * where:
- * 	-c n : run n copies simultaneously.
- *	-e   : Turn on errno logging.
- *	-i n : Execute test n times.
- *	-I x : Execute test for x seconds.
- *	-p   : Pause for SIGUSR1 before starting
- *	-P x : Pause for x seconds between iterations.
- *	-t   : Turn on syscall timing.
- *
- *RESTRICTIONS:
- * Not compatible with kernel versions below 2.1.35
- *
- *CHANGES:
- * 2005/01/01  Add extra check to stop test if insufficient disk space in dir
- *             -Ricky Ng-Adam (rngadam@yahoo.com)
- * 2005/01/01  Add extra check to stop test if swap file is on tmpfs
- *             -Ricky Ng-Adam (rngadam@yahoo.com)
- *****************************************************************************/
+
+ /*
+  * Checks that swapon() succeds with swapfile.
+  */
 
 #include <unistd.h>
 #include <errno.h>
 #include <stdlib.h>
 #include "test.h"
 #include "usctest.h"
-#include "config.h"
 #include "linux_syscall_numbers.h"
-#include "swaponoff.h"
+#include "tst_fs_type.h"
 #include "libswapon.h"
 
-static void setup();
-static void cleanup();
+static void setup(void);
+static void cleanup(void);
 
 char *TCID = "swapon01";
 int TST_TOTAL = 1;
 
+static long fs_type;
+
+static void verify_swapon(void)
+{
+	TEST(ltp_syscall(__NR_swapon, "./swapfile01", 0));
+
+	if (TEST_RETURN == -1) {
+		if (fs_type == TST_BTRFS_MAGIC && errno == EINVAL) {
+			tst_brkm(TCONF, cleanup,
+			         "Swapfile on BTRFS not implemeted");
+			return;
+		}
+		tst_resm(TFAIL | TTERRNO, "Failed to turn on swapfile");
+	} else {
+		tst_resm(TPASS, "Succeeded to turn on swapfile");
+		/*we need to turn this swap file off for -i option */
+		if (ltp_syscall(__NR_swapoff, "./swapfile01") != 0) {
+			tst_brkm(TBROK, cleanup, "Failed to turn off swapfile,"
+			         " system reboot after execution of LTP "
+				 "test suite is recommended.");
+		}
+	}
+}
+
 int main(int ac, char **av)
 {
 
@@ -101,74 +70,39 @@ int main(int ac, char **av)
 	setup();
 
 	for (lc = 0; TEST_LOOPING(lc); lc++) {
-
 		tst_count = 0;
-
-		TEST(ltp_syscall(__NR_swapon, "./swapfile01", 0));
-
-		/* check return code */
-		if (TEST_RETURN == -1) {
-			TEST_ERROR_LOG(TEST_ERRNO);
-			tst_resm(TFAIL, "swapon(2) Failed to turn on"
-				 " swapfile.");
-		} else {
-			tst_resm(TPASS, "swapon(2) passed and turned on"
-				 " swapfile");
-			/*we need to turn this swap file off for -i option */
-			if (ltp_syscall(__NR_swapoff, "./swapfile01") != 0) {
-				tst_brkm(TBROK, cleanup, "Failed to turn off"
-					 " swapfile. system"
-					 " reboot after"
-					 " execution of LTP"
-					 " test suite is" " recommended.");
-			}
-		}
-	}			/*End for TEST_LOOPING */
+		verify_swapon();
+	}
 
 	cleanup();
 	tst_exit();
-
 }
 
-/* setup() - performs all ONE TIME setup for this test */
-void setup()
+static void setup(void)
 {
 	tst_sig(FORK, DEF_HANDLER, cleanup);
 
-	/* Check whether we are root */
-	if (geteuid() != 0) {
-		tst_brkm(TBROK, NULL, "Test must be run as root");
-	}
+	tst_require_root(NULL);
 
 	TEST_PAUSE;
 
 	tst_tmpdir();
 
-	if (tst_is_cwd_tmpfs()) {
-		tst_brkm(TCONF, cleanup,
-			 "Cannot do swapon on a file located on a tmpfs filesystem");
-	}
-
-	if (tst_is_cwd_nfs()) {
+	switch ((fs_type = tst_fs_type(cleanup, "."))) {
+	case TST_NFS_MAGIC:
+	case TST_TMPFS_MAGIC:
 		tst_brkm(TCONF, cleanup,
-			 "Cannot do swapon on a file located on a nfs filesystem");
+			 "Cannot do swapon on a file on %s filesystem",
+			 tst_fs_type_name(fs_type));
+	break;
 	}
 
 	make_swapfile(cleanup, "swapfile01");
 }
 
-/*
- * cleanup() - Performs one time cleanup for this test at
- * completion or premature exit
- */
-void cleanup()
+static void cleanup(void)
 {
-	/*
-	 * print timing stats if that option was specified.
-	 * print errno log if that option was specified.
-	 */
 	TEST_CLEANUP;
 
 	tst_rmdir();
-
 }
diff --git a/testcases/kernel/syscalls/swapon/swapon02.c b/testcases/kernel/syscalls/swapon/swapon02.c
index fb8f89d..aef9e36 100644
--- a/testcases/kernel/syscalls/swapon/swapon02.c
+++ b/testcases/kernel/syscalls/swapon/swapon02.c
@@ -13,75 +13,13 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
  */
-/**************************************************************************
- *
- *    TEST IDENTIFIER	  : swapon02
- *
- *    EXECUTED BY	  : root / superuser
- *
- *    TEST TITLE	  : Test checking for basic error conditions
- *    		            for swapon(2)
- *
- *    TEST CASE TOTAL	  : 5
- *
- *    AUTHOR	 	  : Aniruddha Marathe <aniruddha.marathe@wipro.com> and
- *                          Ricardo Salveti de Araujo <rsalveti@linux.vnet.ibm.com> for
- *                          the EBUSY test case
- *
- *    SIGNALS
- * 		 Uses SIGUSR1 to pause before test if option set.
- * 		  (See the parse_opts(3) man page).
- *
- *    DESCRIPTION
- *		  This test case checks whether swapon(2) system call  returns
- *		  1. ENOENT when the path does not exist
- *		  2. EINVAL when the path exists but is invalid
- *		  3. EPERM when user is not a superuser
- *		  4. EBUSY when the specified path is already being used as a swap area
- *		$
- * 		  Setup:
- *		    Setup signal handling.
- *		    Pause for SIGUSR1 if option specified.
- *		   1. For testing error on invalid user, change the effective uid
- *
- * 		  Test:
- *		    Loop if the proper options are given.
- *		    Execute system call.
- *		    Check return code, if system call fails with errno == expected errno
- *	 	    Issue syscall passed with expected errno
- *		    Otherwise,
- *		    Issue syscall failed to produce expected errno
- *
- * 		  Cleanup:
- * 		    Do cleanup for the test.
- * 		  $
- * USAGE:  <for command-line>
- *  swapon02 [-e] [-i n] [-I x] [-p x] [-t] [-h] [-f] [-p]
- *  where
- *		  -e   : Turn on errno logging.
- *		  -i n : Execute test n times.
- *		  -I x : Execute test for x seconds.
- *		  -p   : Pause for SIGUSR1 before starting
- *		  -P x : Pause for x seconds between iterations.
- *		  -t   : Turn on syscall timing.
- *
- *RESTRICTIONS:
- *Incompatible with kernel versions below 2.1.35.
- *Incompatible if MAX_SWAPFILES definition in later kernels is changed
- * -c option can't be used.
- *
- *CHANGES:
- * 2005/01/01  Add extra check to stop test if swap file is on tmpfs
- *             -Ricky Ng-Adam (rngadam@yahoo.com)
- * 01/02/03  Added fork to handle SIGSEGV generated when the intentional EPERM
- * error for hitting MAX_SWAPFILES is hit.
- * -Robbie Williamson <robbiew@us.ibm.com>
- * 05/17/07  Fixing the test description and added the EBUSY test case
- *           - Ricardo Salveti de Araujo (rsalveti@linux.vnet.ibm.com)
- * 08/16/07  Removed the the 'more than MAX_SWAPFILES swapfiles in use' test
- * case as now we have a separated file only for this test.
- *           - Ricardo Salveti de Araujo (rsalveti@linux.vnet.ibm.com)
- *****************************************************************************/
+/*
+ * This test case checks whether swapon(2) system call  returns
+ *  1. ENOENT when the path does not exist
+ *  2. EINVAL when the path exists but is invalid
+ *  3. EPERM when user is not a superuser
+ *  4. EBUSY when the specified path is already being used as a swap area
+ */
 
 #include <unistd.h>
 #include <errno.h>
@@ -96,47 +34,67 @@
 #include <signal.h>
 #include "test.h"
 #include "usctest.h"
-#include "config.h"
 #include "linux_syscall_numbers.h"
-#include "swaponoff.h"
+#include "safe_macros.h"
+#include "tst_fs_type.h"
 #include "libswapon.h"
 
-static void setup();
-static void cleanup();
-static int setup01();
-static int cleanup01();
-static int setup02();
-static int setup03();
-static int cleanup03();
-void handler(int);
+static void setup(void);
+static void cleanup(void);
+static void setup01(void);
+static void cleanup01(void);
 
 char *TCID = "swapon02";
 int TST_TOTAL = 4;
-char nobody_uid[] = "nobody";
-struct passwd *ltpuser;
 
-struct utsname uval;
-char *kmachine;
+static uid_t nobody_uid;
+static int do_swapoff;
+static long fs_type;
 
 static int exp_enos[] = { EPERM, EINVAL, ENOENT, EBUSY, 0 };
 
 static struct test_case_t {
-	char *err_desc;		/* error description */
-	int exp_errno;		/* expected error number */
-	char *exp_errval;	/* Expected errorvalue string */
-	char *path;		/* path to swapon */
-	int (*setupfunc) ();	/* Test setup function */
-	int (*cleanfunc) ();	/* Test cleanup function */
-} testcase[] = {
-	{
-	"Path does not exist", ENOENT, "ENOENT", "./abcd", NULL, NULL}, {
-	"Invalid path", EINVAL, "EINVAL", "./nofile", setup02, NULL}, {
-	"Permission denied", EPERM, "EPERM", "./swapfile01",
-		    setup01, cleanup01}, {
-	"The specified path is already being used as a swap area",
-		    EBUSY, "EBUSY", "./alreadyused", setup03, cleanup03}
+	char *err_desc;
+	int exp_errno;
+	char *exp_errval;
+	char *path;
+	void (*setup)(void);
+	void (*cleanup)(void);
+} testcases[] = {
+	{"Path does not exist", ENOENT, "ENOENT", "./doesnotexist", NULL, NULL},
+	{"Invalid path", EINVAL, "EINVAL", "./notswap", NULL, NULL},
+	{"Permission denied", EPERM, "EPERM", "./swapfile01",
+	 setup01, cleanup01},
+	{"File already used", EBUSY, "EBUSY", "./alreadyused", NULL, NULL},
 };
 
+static void verify_swapon(struct test_case_t *test)
+{
+	if (test->setup)
+		test->setup();
+
+	TEST(ltp_syscall(__NR_swapon, test->path, 0));
+
+	if (test->cleanup)
+		test->cleanup();
+
+	if (TEST_RETURN == -1 && TEST_ERRNO == test->exp_errno) {
+		tst_resm(TPASS, "swapon(2) expected failure;"
+			 " Got errno - %s : %s",
+			 test->exp_errval, test->err_desc);
+		return;
+	}
+
+	if (fs_type == TST_BTRFS_MAGIC && errno == EINVAL) {
+		tst_resm(TCONF, "Swapfile on BTRFS not implemeted");
+			return;
+	}
+
+	tst_resm(TFAIL, "swapon(2) failed to produce expected error:"
+	         " %d, errno: %s and got %d.", test->exp_errno,
+	         test->exp_errval, TEST_ERRNO);
+}
+
 int main(int ac, char **av)
 {
 	int lc, i;
@@ -145,198 +103,72 @@ int main(int ac, char **av)
 	if ((msg = parse_opts(ac, av, NULL, NULL)) != NULL)
 		tst_brkm(TBROK, NULL, "OPTION PARSING ERROR - %s", msg);
 
-	uname(&uval);
-	kmachine = uval.machine;
 	setup();
 
 	for (lc = 0; TEST_LOOPING(lc); lc++) {
 		tst_count = 0;
-		for (i = 0; i < TST_TOTAL; i++) {
-
-			/* do the setup if the test have one */
-			if (testcase[i].setupfunc
-			    && testcase[i].setupfunc() == -1) {
-				tst_resm(TWARN,
-					 "Failed to setup test %d."
-					 " Skipping test", i);
-				continue;
-			} else {
-				/* run the test */
-				TEST(ltp_syscall(__NR_swapon,
-					testcase[i].path, 0));
-			}
-			/* do the clean if the test have one */
-			if (testcase[i].cleanfunc
-			    && testcase[i].cleanfunc() == -1) {
-				tst_brkm(TBROK, cleanup,
-					 "Cleanup failed, quitting the test");
-			}
-			/* check return code */
-			if ((TEST_RETURN == -1)
-			    && (TEST_ERRNO == testcase[i].exp_errno)) {
-				tst_resm(TPASS,
-					 "swapon(2) expected failure;"
-					 " Got errno - %s : %s",
-					 testcase[i].exp_errval,
-					 testcase[i].err_desc);
-			} else {
-				tst_resm(TFAIL, "swapon(2) failed to produce"
-					 " expected error: %d, errno"
-					 ": %s and got %d. "
-					 " System reboot after"
-					 " execution of LTP"
-					 " test suite is"
-					 " recommended.",
-					 testcase[i].exp_errno,
-					 testcase[i].exp_errval, TEST_ERRNO);
-				/*If swapfile is turned on, turn it off */
-				if (TEST_RETURN == 0) {
-					if (ltp_syscall
-					    (__NR_swapoff,
-					     testcase[i].path) != 0) {
-						tst_resm(TWARN,
-							 "Failed to"
-							 " turn off swapfile"
-							 " swapfile. System"
-							 " reboot after"
-							 " execution of LTP"
-							 " test suite is"
-							 " recommended.");
-					}
-				}
-			}
-			TEST_ERROR_LOG(TEST_ERRNO);
-		}		/*End of TEST LOOPS */
-	}			/*End of TEST LOOPING */
+		for (i = 0; i < TST_TOTAL; i++)
+			verify_swapon(testcases + i);
+	}
 
 	cleanup();
 	tst_exit();
-}				/*End of main */
-
-/*
- * setup01() - This function creates the file and sets the user as nobody
- */
-int setup01()
-{
-	make_swapfile(cleanup, "swapfile01");
-
-	if ((ltpuser = getpwnam(nobody_uid)) == NULL) {
-		tst_resm(TWARN, "\"nobody\" user not present. skipping test");
-		return -1;
-	}
-
-	if (seteuid(ltpuser->pw_uid) == -1) {
-		tst_resm(TWARN, "seteuid failed to "
-			 "to set the effective uid to %d", ltpuser->pw_uid);
-		perror("seteuid");
-		return -1;
-	}
-	return 0;		/* user switched to nobody */
 }
 
-/*
- * cleanup01() - switch back to user root and gives swapoff to the swap file
- */
-int cleanup01()
-{
-	if (seteuid(0) == -1) {
-		tst_brkm(TBROK | TERRNO, cleanup,
-			 "seteuid failed to set uid to root");
-	}
-
-	return 0;
-}
-
-/*
- * setup02() - create a normal file, to be used with swapon
- */
-int setup02()
-{
-	int fd;
-	fd = creat("nofile", S_IRWXU);
-	if (fd == -1)
-		tst_resm(TWARN, "Failed to create temporary file");
-	close(fd);
-	return 0;
-}
-
-/*
- * setup03() - This function creates the swap file and turn it on
- */
-int setup03()
+static void setup01(void)
 {
-	int res = 0;
-
-	make_swapfile(cleanup, "alreadyused");
-
-	/* turn on the swap file */
-	res = ltp_syscall(__NR_swapon, "alreadyused", 0);
-	if (res != 0) {
-		tst_resm(TWARN, "Failed swapon for file alreadyused"
-			 " returned %d", res);
-		return -1;
-	}
-
-	return 0;
+	SAFE_SETEUID(cleanup, nobody_uid);
 }
 
-/*
- * cleanup03() - clearing the turned on swap file
- */
-int cleanup03()
+static void cleanup01(void)
 {
-	/* give swapoff to the test swap file */
-	if (ltp_syscall(__NR_swapoff, "alreadyused") != 0) {
-		tst_resm(TWARN, "Failed to turn off swap files. system"
-			 " reboot after execution of LTP test"
-			 " suite is recommended");
-		return -1;
-	}
-
-	return 0;
+	SAFE_SETEUID(cleanup, 0);
 }
 
-/* setup() - performs all ONE TIME setup for this test */
-void setup()
+static void setup(void)
 {
+	struct passwd *nobody;
 
 	tst_sig(FORK, DEF_HANDLER, cleanup);
 
-	/* set the expected errnos... */
 	TEST_EXP_ENOS(exp_enos);
 
-	/* Check whether we are root */
-	if (geteuid() != 0) {
-		tst_brkm(TBROK, NULL, "Test must be run as root");
-	}
+	tst_require_root(NULL);
+
+	nobody = SAFE_GETPWNAM(cleanup, "nobody");
+	nobody_uid = nobody->pw_uid;
 
 	tst_tmpdir();
 
-	if (tst_is_cwd_tmpfs()) {
+	switch ((fs_type = tst_fs_type(cleanup, "."))) {
+	case TST_NFS_MAGIC:
+	case TST_TMPFS_MAGIC:
 		tst_brkm(TCONF, cleanup,
-			 "Cannot do swapon on a file located on a tmpfs filesystem");
+			 "Cannot do swapon on a file on %s filesystem",
+			 tst_fs_type_name(fs_type));
+	break;
 	}
 
-	if (tst_is_cwd_nfs()) {
-		tst_brkm(TCONF, cleanup,
-			 "Cannot do swapon on a file located on a nfs filesystem");
+	SAFE_TOUCH(cleanup, "notswap", 0777, NULL);
+	make_swapfile(cleanup, "swapfile01");
+	make_swapfile(cleanup, "alreadyused");
+
+	if (ltp_syscall(__NR_swapon, "alreadyused", 0)) {
+		if (fs_type != TST_BTRFS_MAGIC || errno != EINVAL)
+			tst_resm(TWARN | TERRNO, "swapon(alreadyused) failed");
+	} else {
+		do_swapoff = 1;
 	}
 
 	TEST_PAUSE;
-
 }
 
-/*
-* cleanup() - Performs one time cleanup for this test at
-* completion or premature exit
-*/
-void cleanup()
+void cleanup(void)
 {
-	/*
-	 * print timing stats if that option was specified.
-	 * print errno log if that option was specified.
-	 */
 	TEST_CLEANUP;
 
+	if (do_swapoff && ltp_syscall(__NR_swapoff, "alreadyused"))
+		tst_resm(TWARN | TERRNO, "swapoff(alreadyused) failed");
+
 	tst_rmdir();
 }
diff --git a/testcases/kernel/syscalls/swapon/swapon03.c b/testcases/kernel/syscalls/swapon/swapon03.c
index a80e378..8d4a72b 100644
--- a/testcases/kernel/syscalls/swapon/swapon03.c
+++ b/testcases/kernel/syscalls/swapon/swapon03.c
@@ -1,62 +1,29 @@
 /******************************************************************************
  *
- *   Copyright (c) International Business Machines  Corp., 2007
+ * Copyright (c) International Business Machines  Corp., 2007
+ *  Created by <rsalveti@linux.vnet.ibm.com>
  *
- *   This program is free software;  you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
+ * This program is free software;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
  *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
- *   the GNU General Public License for more details.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY;  without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU General Public License for more details.
  *
- *   You should have received a copy of the GNU General Public License
- *   along with this program;  if not, write to the Free Software
- *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ * You should have received a copy of the GNU General Public License
+ * along with this program;  if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  *
- * NAME
- *      swapon03.c
- *
- * DESCRIPTION
- *      This test case checks whether swapon(2) system call returns:
- *        - EPERM when there are more than MAX_SWAPFILES already in use.
- *
- *	Setup:
- *		Setup signal handling.
- *		Pause for SIGUSR1 if option specified.
- * 		Create MAX_SWAPFILES - 2 (to support latest kernels) swapfiles
- *
- *	Test:
- *		Loop if the proper options are given.
- *		Execute system call.
- *		Check return code, if system call fails with errno == expected errno
- *	 	Issue syscall passed with expected errno
- *		Otherwise,
- *		Issue syscall failed to produce expected errno
- *
- * 	Cleanup:
- * 		    Do cleanup for the test.
- *
- * USAGE:  <for command-line>
- *  swapon03 [-e] [-i n] [-I x] [-p x] [-t] [-h] [-f] [-p]
- *  where
- *		  -e   : Turn on errno logging.
- *		  -i n : Execute test n times.
- *		  -I x : Execute test for x seconds.
- *		  -p   : Pause for SIGUSR1 before starting
- *		  -P x : Pause for x seconds between iterations.
- *		  -t   : Turn on syscall timing.
- *
- * Author
- *	Ricardo Salveti de Araujo <rsalveti@linux.vnet.ibm.com> based on
- *	swapon02 created by Aniruddha Marathe
- *
- * History
- *      16/08/2007      Created <rsalveti@linux.vnet.ibm.com>
+ ******************************************************************************/
+
+/*
+ * This test case checks whether swapon(2) system call returns:
+ *  - EPERM when there are more than MAX_SWAPFILES already in use.
  *
-******************************************************************************/
+ */
 
 #include <sys/types.h>
 #include <unistd.h>
@@ -71,39 +38,36 @@
 #include <signal.h>
 #include "test.h"
 #include "usctest.h"
-#include "config.h"
 #include "linux_syscall_numbers.h"
+#include "tst_fs_type.h"
 #include "swaponoff.h"
 #include "libswapon.h"
 
-void setup();
-void cleanup();
-int setup_swap();
-int clean_swap();
-int check_and_swapoff(char *filename);
+static void setup(void);
+static void cleanup(void);
+static int setup_swap(void);
+static int clean_swap(void);
+static int check_and_swapoff(const char *filename);
 
 char *TCID = "swapon03";
 int TST_TOTAL = 1;
 
 static int exp_enos[] = { EPERM, 0 };
 
-static int swapfiles;		/* Number of swapfiles turned on */
+static int swapfiles;
 
-struct utsname uval;
-char *kmachine;
+static long fs_type;
 
-/* Paths for files that we'll use to test */
 int testfiles = 3;
 static struct swap_testfile_t {
 	char *filename;
 } swap_testfiles[] = {
-	{
-	"firstswapfile"}, {
-	"secondswapfile"}, {
-	"thirdswapfile"}
+	{"firstswapfile"},
+	{"secondswapfile"},
+	{"thirdswapfile"}
 };
 
-int expected_errno = EPERM;	/* Expected errno when doing the test */
+int expected_errno = EPERM;
 
 int main(int ac, char **av)
 {
@@ -113,30 +77,19 @@ int main(int ac, char **av)
 	if ((msg = parse_opts(ac, av, NULL, NULL)) != NULL)
 		tst_brkm(TBROK, NULL, "OPTION PARSING ERROR - %s", msg);
 
-	/***************************************************************
-	 * perform global setup for test
-	 ***************************************************************/
-	uname(&uval);
-	kmachine = uval.machine;
 	setup();
 
-	/***************************************************************
-	 * check looping state if -i option given
-	 ***************************************************************/
 	for (lc = 0; TEST_LOOPING(lc); lc++) {
 		tst_count = 0;
 
-		/* do the test setup */
 		if (setup_swap() < 0) {
 			clean_swap();
 			tst_brkm(TBROK, cleanup,
 				 "Setup failed, quitting the test");
 		}
 
-		/* Call swapon sys call for the first time */
 		TEST(ltp_syscall(__NR_swapon, swap_testfiles[0].filename, 0));
 
-		/* Check return code */
 		if ((TEST_RETURN == -1) && (TEST_ERRNO == expected_errno)) {
 			tst_resm(TPASS, "swapon(2) got expected failure (%d),",
 				 expected_errno);
@@ -186,7 +139,6 @@ int main(int ac, char **av)
 			}
 		}
 
-		/* do the clean */
 		if (clean_swap() < 0)
 			tst_brkm(TBROK, cleanup,
 				 "Cleanup failed, quitting the test");
@@ -200,17 +152,17 @@ int main(int ac, char **av)
 
 }
 
-/***************************************************************
- * setup_swap() - Create 33 and activate 30 swapfiles.
- ***************************************************************/
-int setup_swap()
+/*
+ * Create 33 and activate 30 swapfiles.
+ */
+static int setup_swap(void)
 {
 	pid_t pid;
-	int j, fd;		/*j is loop counter, fd is file descriptor */
-	int status;		/* used for fork */
+	int j, fd;
+	int status;
 	int res = 0;
-	char filename[15];	/* array to store new filename */
-	char buf[BUFSIZ + 1];	/* temp buffer for reading /proc/swaps */
+	char filename[15];
+	char buf[BUFSIZ + 1];
 
 	/* Find out how many swapfiles (1 line per entry) already exist */
 	swapfiles = 0;
@@ -271,6 +223,9 @@ int setup_swap()
 			/* turn on the swap file */
 			res = ltp_syscall(__NR_swapon, filename, 0);
 			if (res != 0) {
+				if (fs_type == TST_BTRFS_MAGIC && errno == EINVAL)
+					exit(2);
+
 				if (errno == EPERM) {
 					printf("Successfully created %d "
 					       "swapfiles\n", j);
@@ -286,8 +241,15 @@ int setup_swap()
 	} else
 		waitpid(pid, &status, 0);
 
-	if (WEXITSTATUS(status)) {
+	switch (WEXITSTATUS(status)) {
+	case 0:
+	break;
+	case 2:
+		tst_brkm(TCONF, cleanup, "Swapfile on BTRFS not implemeted");
+	break;
+	default:
 		tst_brkm(TFAIL, cleanup, "Failed to setup swaps");
+	break;
 	}
 
 	/* Create all needed extra swapfiles for testing */
@@ -298,10 +260,10 @@ int setup_swap()
 
 }
 
-/***************************************************************
- * clean_swap() - clearing all turned on swapfiles
- ***************************************************************/
-int clean_swap()
+/*
+ * Turn off all swapfiles previously turned on
+ */
+static int clean_swap(void)
 {
 	int j;
 	char filename[FILENAME_MAX];
@@ -333,11 +295,10 @@ int clean_swap()
 	return 0;
 }
 
-/***************************************************************
- * check_and_swapoff() - check if the file is at /proc/swaps and
- * 			 remove it giving swapoff
- ***************************************************************/
-int check_and_swapoff(char *filename)
+/*
+ * Check if the file is at /proc/swaps and remove it giving swapoff
+ */
+static int check_and_swapoff(const char *filename)
 {
 	char cmd_buffer[256];
 	int rc = -1;
@@ -367,56 +328,35 @@ int check_and_swapoff(char *filename)
 	}
 
 	return rc;
-
 }
 
-/***************************************************************
- * setup() - performs all ONE TIME setup for this test
- ***************************************************************/
-void setup()
+static void setup(void)
 {
-
 	tst_sig(FORK, DEF_HANDLER, cleanup);
 
-	/* set the expected errnos... */
 	TEST_EXP_ENOS(exp_enos);
 
-	/* Check whether we are root */
-	if (geteuid() != 0) {
-		tst_brkm(TBROK, NULL, "Test must be run as root");
-	}
+	tst_require_root(NULL);
 
 	tst_tmpdir();
 
-	if (tst_is_cwd_tmpfs()) {
-		tst_brkm(TCONF, cleanup,
-			 "Cannot do swapon on a file located on a tmpfs filesystem");
-	}
-
-	if (tst_is_cwd_nfs()) {
+	switch ((fs_type = tst_fs_type(cleanup, "."))) {
+	case TST_NFS_MAGIC:
+	case TST_TMPFS_MAGIC:
 		tst_brkm(TCONF, cleanup,
-			 "Cannot do swapon on a file located on a nfs filesystem");
+			 "Cannot do swapon on a file on %s filesystem",
+			 tst_fs_type_name(fs_type));
+	break;
 	}
 
 	TEST_PAUSE;
-
 }
 
-/***************************************************************
- * cleanup() - performs all ONE TIME cleanup for this test at
- *             completion or premature exit.
- ***************************************************************/
-void cleanup()
+static void cleanup(void)
 {
-	/*
-	 * print timing stats if that option was specified.
-	 * print errno log if that option was specified.
-	 */
 	TEST_CLEANUP;
 
-	/* Remove any remaining swap files */
 	clean_swap();
 
 	tst_rmdir();
-
 }
diff --git a/testcases/kernel/syscalls/swapon/swaponoff.h b/testcases/kernel/syscalls/swapon/swaponoff.h
new file mode 100644
index 0000000..e3eae3f
--- /dev/null
+++ b/testcases/kernel/syscalls/swapon/swaponoff.h
@@ -0,0 +1,18 @@
+
+#ifndef __SWAP_ON_OFF_H_
+#define __SWAP_ON_OFF_H_
+
+/*
+ * Read swapon(2) / swapoff(2) for a full history lesson behind the value of
+ * MAX_SWAPFILES.
+ */
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+#define MAX_SWAPFILES 30
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2, 4, 10)
+#define MAX_SWAPFILES 32
+#else
+#define MAX_SWAPFILES 8
+#endif
+
+#endif
diff --git a/testcases/kernel/syscalls/tee/tee01.c b/testcases/kernel/syscalls/tee/tee01.c
index 57b8ba1..5245b27 100644
--- a/testcases/kernel/syscalls/tee/tee01.c
+++ b/testcases/kernel/syscalls/tee/tee01.c
@@ -51,6 +51,7 @@
 #include "test.h"
 #include "usctest.h"
 #include "linux_syscall_numbers.h"
+#include "tst_fs_type.h"
 
 #define SPLICE_TEST_BLOCK_SIZE 1024
 #define SPLICE_F_NONBLOCK (0x02)
@@ -101,12 +102,9 @@ int main(int ac, char **av)
 	 */
 	setup();
 
-	/*
-	 * check if the current filesystem is nfs
-	 */
-	if (tst_is_cwd_nfs()) {
+	if (tst_fs_type(cleanup, ".") == TST_NFS_MAGIC) {
 		tst_brkm(TCONF, cleanup,
-			 "Cannot do tee on a file located on an NFS filesystem");
+			 "Cannot do tee on a file on NFS filesystem");
 	}
 
 	/*
diff --git a/testcases/kernel/syscalls/utime/utime01.c b/testcases/kernel/syscalls/utime/utime01.c
index a0ad30e..3c12420 100644
--- a/testcases/kernel/syscalls/utime/utime01.c
+++ b/testcases/kernel/syscalls/utime/utime01.c
@@ -82,6 +82,7 @@
 
 #include "test.h"
 #include "usctest.h"
+#include "tst_fs_type.h"
 
 #define TEMP_FILE	"tmp_file"
 #define FILE_MODE	S_IRUSR | S_IRGRP | S_IROTH
@@ -99,6 +100,7 @@ int main(int ac, char **av)
 {
 	struct stat stat_buf;	/* struct buffer to hold file info. */
 	int lc;
+	long type;
 	char *msg;
 	time_t modf_time, access_time;
 	time_t pres_time;	/* file modification/access/present time */
@@ -111,17 +113,13 @@ int main(int ac, char **av)
 
 	setup();
 
-	/*
-	 * check if the current filesystem is nfs
-	 */
-	if (tst_is_cwd_nfs()) {
-		tst_brkm(TCONF, cleanup,
-			 "Cannot do utime on a file located on an NFS filesystem");
-	}
-
-	if (tst_is_cwd_v9fs()) {
+	switch ((type = tst_fs_type(cleanup, "."))) {
+	case TST_NFS_MAGIC:
+	case TST_V9FS_MAGIC:
 		tst_brkm(TCONF, cleanup,
-			 "Cannot do utime on a file located on an 9P filesystem");
+			 "Cannot do utime on a file on %s filesystem",
+			 tst_fs_type_name(type));
+	break;
 	}
 
 	/* set the expected errnos... */
diff --git a/testcases/kernel/syscalls/utime/utime02.c b/testcases/kernel/syscalls/utime/utime02.c
index 32303ae..76c7e33 100644
--- a/testcases/kernel/syscalls/utime/utime02.c
+++ b/testcases/kernel/syscalls/utime/utime02.c
@@ -85,6 +85,7 @@
 
 #include "test.h"
 #include "usctest.h"
+#include "tst_fs_type.h"
 
 #define TEMP_FILE	"tmp_file"
 #define FILE_MODE	S_IRUSR | S_IRGRP | S_IROTH
@@ -105,6 +106,7 @@ int main(int ac, char **av)
 {
 	struct stat stat_buf;	/* struct buffer to hold file info. */
 	int lc;
+	long type;
 	char *msg;
 	time_t modf_time, access_time;
 	time_t pres_time;	/* file modification/access/present time */
@@ -117,17 +119,13 @@ int main(int ac, char **av)
 
 	setup();
 
-	/*
-	 * check if the current filesystem is nfs
-	 */
-	if (tst_is_cwd_nfs()) {
-		tst_brkm(TCONF, cleanup,
-			 "Cannot do utime on a file located on an NFS filesystem");
-	}
-
-	if (tst_is_cwd_v9fs()) {
+	switch ((type = tst_fs_type(cleanup, "."))) {
+	case TST_NFS_MAGIC:
+	case TST_V9FS_MAGIC:
 		tst_brkm(TCONF, cleanup,
-			 "Cannot do utime on a file located on an 9P filesystem");
+			 "Cannot do utime on a file on %s filesystem",
+			 tst_fs_type_name(type));
+	break;
 	}
 
 	/* set the expected errnos... */
diff --git a/testcases/kernel/syscalls/utime/utime03.c b/testcases/kernel/syscalls/utime/utime03.c
index 8ce0d79..09dcb94 100644
--- a/testcases/kernel/syscalls/utime/utime03.c
+++ b/testcases/kernel/syscalls/utime/utime03.c
@@ -90,6 +90,7 @@
 
 #include "test.h"
 #include "usctest.h"
+#include "tst_fs_type.h"
 
 #define TEMP_FILE	"tmp_file"
 #define FILE_MODE	S_IRWXU | S_IRGRP | S_IWGRP| S_IROTH | S_IWOTH
@@ -114,6 +115,7 @@ int main(int ac, char **av)
 {
 	struct stat stat_buf;	/* struct buffer to hold file info. */
 	int lc;
+	long type;
 	char *msg;
 	time_t modf_time, access_time;
 	time_t pres_time;	/* file modification/access/present time */
@@ -127,17 +129,13 @@ int main(int ac, char **av)
 
 	setup();
 
-	/*
-	 * check if the current filesystem is nfs
-	 */
-	if (tst_is_cwd_nfs()) {
-		tst_brkm(TCONF, cleanup,
-			 "Cannot do utime on a file located on an NFS filesystem");
-	}
-
-	if (tst_is_cwd_v9fs()) {
+	switch ((type = tst_fs_type(cleanup, "."))) {
+	case TST_NFS_MAGIC:
+	case TST_V9FS_MAGIC:
 		tst_brkm(TCONF, cleanup,
-			 "Cannot do utime on a file located on an 9P filesystem");
+			 "Cannot do utime on a file on %s filesystem",
+			 tst_fs_type_name(type));
+	break;
 	}
 
 	/* set the expected errnos... */
diff --git a/testcases/kernel/syscalls/vmsplice/vmsplice01.c b/testcases/kernel/syscalls/vmsplice/vmsplice01.c
index 4276102..89c2d03 100644
--- a/testcases/kernel/syscalls/vmsplice/vmsplice01.c
+++ b/testcases/kernel/syscalls/vmsplice/vmsplice01.c
@@ -54,6 +54,7 @@
 #include "test.h"
 #include "usctest.h"
 #include "linux_syscall_numbers.h"
+#include "tst_fs_type.h"
 
 #define SPLICE_TEST_BLOCK_SIZE (1<<17)	/* 128K */
 
@@ -215,7 +216,7 @@ static int vmsplice_test(void)
 		/*
 		 * check if the current filesystem is nfs
 		 */
-		if (tst_is_cwd_nfs()) {
+		if (tst_fs_type(cleanup, ".") == TST_NFS_MAGIC) {
 			if (flag == 1)
 				tst_resm(TINFO, "vmplice() passes");
 			tst_brkm(TCONF, cleanup, "Cannot do splice() "
-- 
1.8.3.2

