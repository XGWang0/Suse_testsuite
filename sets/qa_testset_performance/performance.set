#!/bin/bash
# Global eviorment
# ================
# SLE_RELEASE
# Its value should be the test target, for examples SLE11SP3, SLE12.
# It is used for difference between different SLE release.
#
# how to add a new run
# ====================
# each run has there basic components thay are:
#  1. ${run_name}
#  2. ${run_name}_open  ${ARCH} ${SLE_BUILD}  # prepare
#  3. ${run_name}_close ${ARCH} ${SLE_BUILD}  # clean
# TODO _get_args
# if ${run_name} dose no exist or
# either ${run_name}_open or ${run_name}_close fails,
# the run can not be called.
#

# All perf
# reaim_btrfs  #ready
# reaim_ext3   #ready
# reaim_xfs    #ready
#
# tiobench_btrfs  #ready
# tiobench_ext3   #ready
# tiobench_xfs    #ready
#
# tiobench_sync_ext3  #ready
# tiobench_sync_btrfs #ready
# tiobench_sync_xfs   #ready
#
# dbench4_btrfs     #ready
# dbench4_ext3      #ready
# dbench4_xfs       #ready
#
# dbench4_syncIO_btrfs   #ready
# dbench4_syncIO_ext3    #ready
# dbench4_syncIO_xfs     #ready
#
# bonnie_btrfs  #ready
# bonnie_ext3   #ready
# bonnie_xfs    #ready
#
# bonnie_direct_btrfs  #ready
# bonnie_direct_ext3   #ready
# bonnie_direct_xfs    #ready
#
# iozone_btrfs  #ready
# iozone_ext3   #ready
# iozone_xfs    #ready
#
# kernbench     #ready
# lmbench       #ready
# siege         #ready
# libmicro_bench #ready
# sysbench_bench #ready

# __import sq-util.sh
# __import sq-global.sh

nothing_run="${__IMPORT_ROOT}/sq-fake.sh"
function nothing_open {
    sq_debug "[Nothing] open"
}
function nothing_close {
    sq_debug "[Nothing] close"
}
function nothing_get_args {
    echo 'nothing args'
}

# File system test runs for btrfs, ext3, xfs
function sq_abuild_open {
    sq_debug "[abuild] check /etc/fstab for /abuild."
    if test "X${SQ_ABUILD_JUST_DIR}" == "XYES"; then
        sq_debug "[abuild] just use /abuild"
        mkdir /abuild 2>/dev/null
        return 0
    fi

    if test "X${SQ_ABUILD_PARTITION}" != "X";then
        sq_debug "[abuild] predefined SQ_ABUILD_PARTITION ."
        SQ_ABUILD_DEFAULT_FS=""
        #make sure /abuild is there
        test -d /abuild || mkdir /abuild > /dev/null 2>&1
    elif egrep '^[^#].*/abuild' /etc/fstab;then
        sq_debug "[abuild] found a record in /etc/fstab for /abuild."
        SQ_ABUILD_DEFAULT_FS=$(grep '/abuild' /etc/fstab | awk '{print $3}')
        SQ_ABUILD_PARTITION=$(egrep -o '^/dev/.* *\/abuild' /proc/mounts | cut -d" " -f1)
        if test "X${SQ_ABUILD_PARTITION}" == "X";then
            sq_error "[abuild] but currently there is no partition mounted under /abuild"
            return 1
        fi
    else # there is partition default mounted under /abuild
        sq_debug "[abuild] NO record for /abuild in /etc/fstab ."
        SQ_ABUILD_DEFAULT_FS=""
        SQ_ABUILD_PARTITION="/dev/sdb1"
        #make sure /abuild is there
        test -d /abuild || mkdir /abuild > /dev/null 2>&1
    fi
    if test -b ${SQ_ABUILD_PARTITION};then
        sq_info "[abuild] the target partition: ${SQ_ABUILD_PARTITION}"
    else
        sq_error "[abuild] there is no target partition will be used."
        return 2
    fi
}

function sq_abuild_close {
    if test "X${SQ_ABUILD_JUST_DIR}" == "XYES";then
        return 0
    fi
    if test "X${SQ_ABUILD_DEFAULT_FS}" != "X";then
        sq_debug "[abuild] SQ_ABUILD_DEFAULT_FS is ${SQ_ABUILD_DEFAULT_FS}." \
            "[abuild] RESTORE the filesystem to ${SQ_ABUILD_DEFAULT_FS}." \
            "[abuild] then mount ${SQ_ABUILD_PARTITION} /abuild."
        sq_abuild_set_fs ${SQ_ABUILD_DEFAULT_FS}
    fi
}

function sq_abuild_set_fs {
    local _fs_type=$1
    local _fs_options=$2
    local _part
    _part=${SQ_ABUILD_PARTITION}

    if test "X${SQ_ABUILD_JUST_DIR}" == "XYES";then
        return 0
    fi

    if test "X${_part}" == "X";then
        sq_warn "[abuild] trying to mount NODEV /abuild." \
            "Check the system."
        return 1
    fi

    if egrep -o "^${_part}" /proc/mounts;then
        sq_debug "[abuild] ${_part} is already used"
        umount ${_part}
        if test $? -ne 0; then
            sq_error "[abuild] Failed to umount ${_part}." \
                "/abuild is supposed to be free." \
                "There is a BUG!!!"
            return 2
        else
            sq_debug "[abuild] umount ${_part} successfully."
        fi
    fi

    case ${_fs_type} in
        ext3)
            ${SQ_DEBUG_ECHO} /sbin/mkfs.ext3 ${_fs_options} ${_part} > /dev/null;;
        xfs)
            ${SQ_DEBUG_ECHO} /sbin/mkfs.xfs -f ${_fs_options} ${_part} > /dev/null ;;
        btrfs) ${SQ_DEBUG_ECHO} /sbin/mkfs.btrfs -f ${_fs_options} ${_part} > /dev/null ;;
        *) sq_warn "[abuild] ${_fs_type} is not supportted!!!"; true;;
    esac

    if test $? -ne 0; then
        sq_error "[abuild] format ${_part} to ${_fs_type} failed!!!"
        return 3
    else
        sq_info "[abuild] format ${_part} to ${_fs_type} successfully."
    fi

    mount ${_part} /abuild
    if test $? -ne 0; then
        sq_error "[abuild] mount ${_part} /abuild failed!!!"
        return 4
    else
        sq_info "[abuild] mount ${_part} /abuild successfully."
    fi
}

function sq_abuild_general_open {
    sq_abuild_open
    if test $? -ne 0;then
        return 1
    fi
    sq_abuild_set_fs $1
    if test $? -ne 0;then
        sq_abuild_close
        return 2
    fi
}

function sq_abuild_general_close {
    sq_abuild_close
}

### reaim
_reaim_run="/usr/lib/ctcs2/tools/test_reaim-run"
reaim_btrfs_run=${_reaim_run}
function reaim_btrfs_open {
    sq_abuild_general_open btrfs
}
function reaim_btrfs_close {
    sq_abuild_general_close
}

reaim_ext3_run=${_reaim_run}
function reaim_ext3_open {
    sq_abuild_general_open ext3
}
function reaim_ext3_close {
    sq_abuild_general_close
}

reaim_xfs_run=${_reaim_run}
function reaim_xfs_open {
    sq_abuild_general_open xfs
}
function reaim_xfs_close {
    sq_abuild_close
}

### bonnie
_bonnie_run="/usr/share/qa/tools/test_bonnie-run"
bonnie_ext3_run=${_bonnie_run}
function bonnie_ext3_open {
    sq_abuild_general_open ext3
}
function bonnie_ext3_close {
    sq_abuild_general_close
}

bonnie_xfs_run=${_bonnie_run}
function bonnie_xfs_open {
    sq_abuild_general_open xfs
}
function bonnie_xfs_close {
    sq_abuild_general_close
}

bonnie_btrfs_run=${_bonnie_run}
function bonnie_btrfs_open {
    sq_abuild_general_open btrfs
}
function bonnie_btrfs_close {
    sq_abuild_general_close
}

## bonnie direct
_bonnie_direct_run="/usr/share/qa/tools/test_bonnie-directIO-run"
bonnie_direct_ext3_run=${_bonnie_direct_run}
function bonnie_direct_ext3_open {
    sq_abuild_general_open ext3
}
function bonnie_direct_ext3_close {
    sq_abuild_general_close
}

bonnie_direct_xfs_run=${_bonnie_direct_run}
function bonnie_direct_xfs_open {
    sq_abuild_general_open xfs
}
function bonnie_direct_xfs_close {
    sq_abuild_general_close
}

bonnie_direct_btrfs_run=${_bonnie_direct_run}
function bonnie_direct_btrfs_open {
    sq_abuild_general_open btrfs
}
function bonnie_direct_btrfs_close {
    sq_abuild_general_close
}

##iozone
_iozone_run="/usr/share/qa/tools/test_iozone_new_run"
iozone_ext3_run=${_iozone_run}
function iozone_ext3_open {
    sq_abuild_general_open ext3
}
function iozone_ext3_close {
    sq_abuild_general_close
}

iozone_xfs_run=${_iozone_run}
function iozone_xfs_open {
    sq_abuild_general_open xfs
}
function iozone_xfs_close {
    sq_abuild_general_close
}

iozone_btrfs_run=${_iozone_run}
function iozone_btrfs_open {
    sq_abuild_general_open btrfs
}
function iozone_btrfs_close {
    sq_abuild_general_close
}

## dbench
_dbench4_run="/usr/share/qa/tools/test_dbench-4_0-run"
dbench4_ext3_run=${_dbench4_run}
function dbench4_ext3_open {
    sq_abuild_general_open ext3
}
function dbench4_ext3_close {
    sq_abuild_general_close
}

dbench4_xfs_run=${_dbench4_run}
function dbench4_xfs_open {
    sq_abuild_general_open xfs
}
function dbench4_xfs_close {
    sq_abuild_general_close
}

dbench4_btrfs_run=${_dbench4_run}
function dbench4_btrfs_open {
    sq_abuild_general_open btrfs
}
function dbench4_btrfs_close {
    sq_abuild_general_close
}

_dbench4_syncIO_run="/usr/share/qa/tools/test_dbench-4_0-syncIO-run"
dbench4_syncIO_ext3_run=${_dbench4_syncIO_run}
function dbench4_syncIO_ext3_open {
    sq_abuild_general_open ext3
}
function dbench4_syncIO_ext3_close {
    sq_abuild_general_close
}

dbench4_syncIO_btrfs_run=${_dbench4_syncIO_run}
function dbench4_syncIO_btrfs_open {
    sq_abuild_general_open btrfs
}
function dbench4_syncIO_btrfs_close {
    sq_abuild_general_close
}

dbench4_syncIO_xfs_run=${_dbench4_syncIO_run}
function dbench4_syncIO_xfs_open {
    sq_abuild_general_open xfs
}
function dbench4_syncIO_xfs_close {
    sq_abuild_general_close
}

### dbench nfs
dbench4_nfs="/usr/share/qa/tools/test_dbench-4_0-nfs-run"
### dbench nfs4
dbench4_nfs4="/usr/share/qa/tools/test_dbench-4_0-nfs4-run"

### tiobench
function tiobench_set_tcf {
    local _arch
    local _tcf
    _arch=$1
    _tcf=$2
    case ${_arch} in
        x86_64)
            # TODO why this could no be done in qa_test_tiobench ???
            cp /usr/share/qa/tcf/${_tcf} /usr/share/qa/tcf/${_tcf}.orig 2>/dev/null
            sed -i "s/--size [0-9]\+/--size 32768/" /usr/share/qa/tcf/${_tcf}
            sq_debug "[tiobench] ${_tcf} has been changed."
cat <<EOF > /usr/lib/ctcs2/tools/sq-tiobench-bench-run
#!/bin/sh

CTCS2_DIR=/usr/lib/ctcs2
TCF_DIR=/usr/share/qa/tcf

\$CTCS2_DIR/tools/run \$TCF_DIR/${_tcf}
EOF
            chmod +x /usr/lib/ctcs2/tools/sq-tiobench-bench-run
            ;;
    esac
}
function tiobench_reset_tcf {
    local _tcf
    _tcf=$1
    if test "X${SQ_DEBUG_ON}" == "XYES";then
        cp /usr/share/qa/tcf/${_tcf} /usr/share/qa/tcf/${_tcf}.sq
        mv /usr/share/qa/tcf/${_tcf}.orig /usr/share/qa/tcf/${_tcf} 2>/dev/null
        return
    fi
    mv /usr/share/qa/tcf/${_tcf}.orig /usr/share/qa/tcf/${_tcf} 2>/dev/null
    rm /usr/lib/ctcs2/tools/sq-tiobench-bench-run
}
function tiobench_general_open {
    local _arch=$1
    local _fs=$2
    local _tcf=$3
    sq_abuild_open
    if test $? -ne 0;then
        return 1
    fi
    sq_abuild_set_fs ${_fs}
    if test $? -ne 0;then
        sq_abuild_close
        return 2
    fi
    tiobench_set_tcf ${_arch} ${_tcf}
    if test $? -ne 0;then
        return 3
    fi
}
function tiobench_general_close {
    tiobench_reset_tcf $1
    sq_abuild_close
}

_tiobench_run="/usr/lib/ctcs2/tools/sq-tiobench-bench-run"
tiobench_ext3_run=${_tiobench_run}
function tiobench_ext3_open {
    local _arch=$1
    tiobench_general_open ${_arch} ext3 tiobench-bench.tcf
}
function tiobench_ext3_close {
    tiobench_general_close tiobench-bench.tcf
}

tiobench_xfs_run=${_tiobench_run}
function tiobench_xfs_open {
    local _arch=$1
    tiobench_general_open ${_arch} xfs tiobench-bench.tcf
}
function tiobench_xfs_close {
    tiobench_general_close tiobench-bench.tcf
}

tiobench_btrfs_run=${_tiobench_run}
function tiobench_btrfs_open {
    local _arch=$1
    tiobench_general_open ${_arch} btrfs tiobench-bench.tcf
}
function tiobench_btrfs_close {
    tiobench_general_close tiobench-bench.tcf
}

_tiobench_sync_run="/usr/lib/ctcs2/tools/sq-tiobench-bench-run"
tiobench_sync_ext3_run=${_tiobench_sync_run}
function tiobench_sync_ext3_open {
    local _arch=$1
    tiobench_general_open ${_arch} ext3 tiobench-sync.tcf
    return $?
}
function tiobench_sync_ext3_close {
    tiobench_general_close tiobench-sync.tcf
}

tiobench_sync_xfs_run=${_tiobench_sync_run}
function tiobench_sync_xfs_open {
    tiobench_general_open "$1" xfs tiobench-sync.tcf
    return $?
}
function tiobench_sync_xfs_close {
    tiobench_general_close tiobench-sync.tcf
}

tiobench_sync_btrfs_run=${_tiobench_sync_run}
function tiobench_sync_btrfs_open {
    tiobench_general_open "$1" btrfs tiobench-sync.tcf
    return $?
}
function tiobench_sync_btrfs_close {
    tiobench_general_close tiobench-sync.tcf
}


### libmicro
libmicro_bench_run="/usr/share/qa/tools/test_libmicro-bench-run"

### sysbench bench
sysbench_bench_run="/usr/lib/ctcs2/tools/test_sysbench-bench-run"
function sysbench_bench_open {
    # In sysbench-bench.tcf mysql is started. and a connection is to be set.
    # But if it is the first time that mysql run in the system
    # there is a race condiction which causes the connection to be failed.
    # this should be fixed in the tcf.
    /etc/init.d/mysql start
}
function sysbench_bench_close {
    # In sysbench-bench.tcf mysql is not stop after the runs.
    # So stop mysql here.
    # this should be fixed in the tcf.
    /etc/init.d/mysql stop
}
### siege
siege_run="/usr/share/qa/tools/test_siege-run"
function siege_get_args {
    echo performance
}

### lmbench
lmbench_run="/usr/share/qa/tools/test_lmbench-run"

##kernbench a server is need to store the kernel-package
kernbench_run="/usr/share/qa/tools/test_kernbench-run"
function kernbench_open {
    local _kernel_source=linux-2.6.14
    local _kernel_package=${_kernel_source}.tar.bz2
    local _kernel_package_URL=http://147.2.207.100/kernels/${_kernel_package}
    cd /usr/src
    mv linux linux.sq_orig 2>/dev/null
    if test -f ${_kernel_package} && tar xf ${_kernel_package};then
        sq_debug "[kernbench] The ${_kernel_source} is alreay there."
        mv ${_kernel_source} linux
    else
        wget ${_kernel_package_URL} && tar xf ${_kernel_package}
        sq_debug "[kernbench] Get the ${_kernel_package} from ${_kernel_package_URL}"
        mv ${_kernel_source} linux
    fi

    if test $? -ne 0;then
        return 1
    fi
}
function kernbench_close {
    cd /usr/src
    rm -rf linux 2 > /dev/null
    mv linux.sq_orig linux 2>/dev/null
}

#pgbench
pgbench_btrfs_run="/usr/share/qa/tools/simple-pgbench-run"
function pgbench_btrfs_open {
    sq_abuild_general_open btrfs
}
function pgbench_btrfs_close {
    sq_abuild_general_close
}
pgbench_ext3_run="/usr/share/qa/tools/simple-pgbench-run"
function pgbench_btrfs_open {
    sq_abuild_general_open ext3
}
function pgbench_btrfs_close {
    sq_abuild_general_close
}
pgbench_xfs_run="/usr/share/qa/tools/simple-pgbench-run"
function pgbench_btrfs_open {
    sq_abuild_general_open xfs
}
function pgbench_btrfs_close {
    sq_abuild_general_close
}

