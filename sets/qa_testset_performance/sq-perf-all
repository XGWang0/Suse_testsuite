#!/bin/bash

SLE_RELEASE=$1
shift

SQ_DEBUG_ON=NO

CMDABSPATH=$(which $0)
if [ -L $CMDABSPATH ];then
    cd $(dirname $CMDABSPATH)
    CMDABSPATH=$(readlink $CMDABSPATH)
fi
cd $(dirname $CMDABSPATH) > /dev/null
COMMONDIR=$(pwd)
cd

. ${COMMONDIR}/global.sh
. ${COMMONDIR}/utils.sh
. ${COMMONDIR}/${SLE_RELEASE}.conf
. ${COMMONDIR}/${SLE_RELEASE}.list

SQ_FAKE_RUN=${COMMONDIR}/delay60s.sh

sq_info "[GLOBAL] $0 start at $(date '+%Y-%m-%d-%H-%M-%S')"
sq_info "[GLOBAL] /proc/uptime: $(cat /proc/uptime)"

if test $UID -ne 0;then
    sq_error "I need root permission!!!"
    exit 1
fi

# get the release
SLE_BUILD=`egrep -o '([aA]lpha|[bB]eta|RC)[1-9]' /etc/issue`
if [ -z "${SLE_BUILD}" ]; then
     SLE_BUILD="GMC"
     #TODO to get the meanings of GM and GMC
fi

ARCH=$HOSTTYPE
if [ "$ARCH" != "" ]; then
        case $ARCH in
        i[3-9]86)  ARCH="i586";;
        p*pc) ARCH="ppc";;
        p*pc64) ARCH="ppc64";;
        # TODO ppc64le
        esac
else
        sq_error "cannot determine architecture";
        exit 3
fi

REPO_MIRROR="DE"
sq_info "[GLOBAL] ARCH: ${ARCH}" \
    "[GLOBAL] SLE_BUILD: ${SLE_BUILD}" \
    "[GLOBAL] REPO_MIRROR: ${REPO_MIRROR}"

function sq_prep_all {
    if test -f ${SQ_TEST_CONTROL_FILE_PREPARED};then
        sq_info "[PREP] Preparation: NOT NEED."
    else
        sq_info "[PREP] Preparation: is doing"
        sq_prep_repos_and_packages ${ARCH} ${SLE_BUILD} ${REPO_MIRROR}
        if test $? -ne 0;then
            sq_error "[PREP] preparation: failed!"
            exit -1
        fi
        echo "$(date)" > ${SQ_TEST_CONTROL_FILE_PREPARED}
    fi
    sq_info "[PREP] Preparation: tag system clean."
    rm -f ${SQ_TEST_CONTROL_FILE_SYSTEM_DIRTY} 2>/dev/null
}

function sq_qadb_submit_result {
    local _sq_run
    local _serial
    _sq_run=$1
    #if grep bej\.suse\.com /etc/HOSTNAME > /dev/null
    if ip -4 addr | grep "inet 147\.2\." > /dev/null;then
        SQ_HOSTNAME=${HOSTNAME}.apac.novell.com
    else
        SQ_HOSTNAME=${HOSTNAME}
    fi
    sq_info "[qadb] TODO submit result!!!"
    sq_info "[qadb] currently backup /var/log/qa/ctcs2"

    /usr/share/qa/tools/remote_qa_db_report.pl -b -m "${SQ_HOSTNAME}" -c "Performance ${_sq_run}"
    if test $? -ne 0;then
        sq_warn "[qadb] Submit qa_db_report failed!"
	sq_info "[qadb] Than Backup it!"

    _serial=$(date '+%Y-%m-%d-%H-%M-%S')
    pushd /var/log/qa/ctcs2 > /dev/null

    if test "X${SQ_DEBUG_ON}" == "XYES";then
        tar -c * | xz > ${SQ_TEST_LOG_DIR}/debug.${_sq_run}-${_serial}.tar.xz
    else
        tar -c * | xz > ${SQ_TEST_LOG_DIR}/${_sq_run}-${_serial}.tar.xz
    fi

    if test $? -ne 0;then
        sq_error "[qadb] tar ${_sq_run}-${_serial}.tar.xz FAILED."
        pushd /var/log/qa/ > /dev/null
        mv ctcs2 ctcs2.${run}
        mkdir ctcs2
        popd
    else
        sq_debug "[qadb] tar ${_sq_run}-${_serial}.tar.xz successfully."
        rm -rf *
    fi
    popd > /dev/null


    fi
}

function sq_call_run {
    local sq_run
    local _run_start
    local _run_end
    local _run_start_s
    local _run_end_s
    local _run_dr_s
    local _run_dr_h
    local _run_dr_m
    local _run_stat_file
    
    sq_run=$1

    sq_info "[RUN] ${sq_run}: starting ..."
    if test "X$(type -t ${sq_run}_open)" == "Xfunction";then
        sq_debug "[RUN] ${sq_run}: ${sq_run}_open ing..."
        ${sq_run}_open ${ARCH} ${SLE_BUILD}
    else
        sq_debug "[RUN] ${sq_run}: opening..."
        true
    fi

    if test $? -ne 0;then
        sq_error "[RUN] ${sq_run}: ${sq_run}_open failed!!!" \
            "Skip ${sq_run}"
        if test "X$(type -t ${sq_run}_close)" == "Xfunction";then
            sq_debug "[RUN] ${sq_run}: ${sq_run}_close ing..."
            ${sq_run}_close ${ARCH} ${SLE_BUILD}
        else
            sq_debug "[RUN] ${sq_run}: closing"
        fi
        return 1
    fi

    if eval "test \"X\${${sq_run}_run}\" == X";then
        sq_inner_script="/usr/share/qa/tools/test_${sq_run}_run"
        sq_debug "[RUN] ${sq_run}: [G] ${sq_inner_script}"
    else
        eval "sq_inner_script=\${${sq_run}_run}"
        sq_debug "[RUN] ${sq_run}: [S] ${sq_inner_script}"
    fi

    if test ! -x ${sq_inner_script};then
        sq_error "[RUN] ${sq_run}: ${sq_inner_script} dose not exist!!!"
        if test "X$(type -t ${sq_run}_close)" == "Xfunction";then
            sq_debug "[RUN] ${sq_run}: ${sq_run}_close ing..."
            ${sq_run}_close ${ARCH} ${SLE_BUILD}
        else
            sq_debug "[RUN] ${sq_run}: closing"
        fi
        return 1
    fi

    pushd ${SQ_TEST_RUN_DIR} > /dev/null #make sure it runs at /root
    rm screenlog.0 2>/dev/null
    _run_start=$(date '+%Y-%m-%d-%H-%M-%S')
    _run_start_s=$(date '+%s')
    sq_info "[RUN] ${sq_run}: Begin: ${_run_start}"
    # TODO backgroud call
    if test "X$(type -t ${sq_run}_get_args)" == "Xfunction";then
        sq_debug "[RUN] ${sq_run}: ${sq_run}_get_args ing..."
        if test $SQ_DEBUG_ON == YES;then
            screen -L -S ${sq_run} -D -m "${SQ_FAKE_RUN}" $(${sq_run}_get_args)
        else
            screen -L -S ${sq_run} -D -m "$sq_inner_script" $(${sq_run}_get_args)
        fi
    else
        if test $SQ_DEBUG_ON == YES;then
            screen -L -S ${sq_run} -D -m "${SQ_FAKE_RUN}"
        else
            screen -L -S ${sq_run} -D -m "$sq_inner_script"
        fi
    fi
    _run_end_s=$(date '+%s')
    _run_end=$(date '+%Y-%m-%d-%H-%M-%S')
    sq_info "[RUN] ${sq_run}: End: ${_run_end}"
    if test $SQ_DEBUG_ON == YES;then
        mv screenlog.0 debug.screenlog.${_run_start}.${sq_run}
        _run_stat_file=debug.run.statistic
    else
        mv screenlog.0 screenlog.${_run_start}.${sq_run}
        _run_stat_file=run.statistic
    fi
    echo "[RUN] ${sq_run}: Begin: ${_run_start}" >> ${_run_stat_file}
    echo "[RUN] ${sq_run}: End: ${_run_end}" >> ${_run_stat_file}
    _run_dr_s=$((${_run_end_s} - ${_run_start_s}))
    _run_dr_h=$((${_run_dr_s} / 3600))
    _run_dr_m=$((${_run_dr_s} % 3600 / 60))
    echo "[RUN] ${sq_run} Duration: ${_run_dr_h}h${_run_dr_m}m" >> ${_run_stat_file}
    popd > /dev/null
    # clean up
    if test "X$(type -t ${sq_run}_close)" == "Xfunction";then
        sq_debug "[RUN] ${sq_run}: ${sq_run}_close ing..."
        ${sq_run}_close ${ARCH} ${SLE_BUILD}
    else
        sq_debug "[RUN] ${sq_run}: closing"
    fi
    sq_info "[RUN] ${sq_run}: finished."

    if test $? -eq 0;then
        sq_qadb_submit_result ${sq_run}
    else
        sq_error "[RUN] ${sq_run}: something wrong!" \
            "the result will not be submitted."
    fi
}


function sq_control_get_next_run {
    ### the control policy

    if test -f ${SQ_TEST_CONTROL_FILE_STOP};then
        sq_info "[CONTROL]: this run is manually stopped!"
        return 1
    fi

    if test -f ${SQ_TEST_CONTROL_FILE_SYSTEM_DIRTY};then
        SQ_TEST_CONTROL_MAKE_SYSTEM_PURE=YES
        sq_debug "[CONTROL]: This system is dirty."
        # TODO test reboot needed
        if test "X$SQ_TEST_CONTROL_IGNORE_SYSTEM_DIRTY" == "XNO";then
            return 2
        fi
    fi

    if test -f ${SQ_TEST_CONTROL_FILE_DONE};then
        sq_info "[CONTROL]: This round of runs was already finished at $(cat ${SQ_TEST_CONTROL_FILE_DONE})"
        return 3
    fi

    ### the operation of run lists
    if test ${#SQ_TEST_RUN_PERF_LIST[*]} -le 0;then
        sq_error "SQ_TEST_RUN_PERF_LIST is none" \
            "Plase check the ${SLE_RELEASE}.list file."
        exit -1
    fi

    sq_debug "[CONTROL] TRY A NEW RUN ##################"
    if test -f ${SQ_TEST_CONTROL_FILE_NEXT_RUN};then
        read SQ_THIS_RUN_INDEX SQ_THIS_RUN < ${SQ_TEST_CONTROL_FILE_NEXT_RUN}
    else
        SQ_THIS_RUN_INDEX=""
        SQ_THIS_RUN=""
    fi

    if test "X${SQ_THIS_RUN_INDEX}" == "X";then
        SQ_THIS_RUN_INDEX=0
    fi

    if test $SQ_THIS_RUN_INDEX -ge ${#SQ_TEST_RUN_PERF_LIST[*]};then
        sq_error "the run list is out of SQ_TEST_RUN_PERF_LIST"
        exit -1
    fi

    SQ_THIS_RUN="${SQ_TEST_RUN_PERF_LIST[$SQ_THIS_RUN_INDEX]}"
    sq_debug "[CONTROL] THIS RUN: ${SQ_THIS_RUN}"
    sq_debug "[CONTROL] THIS RUN INDEX ${SQ_THIS_RUN_INDEX}"

    SQ_NEXT_RUN_INDEX=$(($SQ_THIS_RUN_INDEX + 1))
    if test $SQ_NEXT_RUN_INDEX -ge ${#SQ_TEST_RUN_PERF_LIST[*]};then
        echo > ${SQ_TEST_CONTROL_FILE_NEXT_RUN}
        sq_debug "[CONTROL] THIS RUN is the last one."        
        SQ_NEXT_RUN_INDEX=""
        SQ_NEXT_RUN=""
    else
        SQ_NEXT_RUN="${SQ_TEST_RUN_PERF_LIST[$SQ_NEXT_RUN_INDEX]}"
        sq_debug "[CONTROL] NEXT RUN: ${SQ_NEXT_RUN}"
    fi

    echo "${SQ_NEXT_RUN_INDEX}" "${SQ_NEXT_RUN}" > ${SQ_TEST_CONTROL_FILE_NEXT_RUN}
}

function sq_control_get_run_status {
    local _run_ret

    _run_ret=$1

    if test ${_run_ret} -eq 0;then
        sq_debug "[CONTROL]: tag the system dirty"
        echo "$(date '+%Y-%m-%d-%H-%M-%S')" > ${SQ_TEST_CONTROL_FILE_SYSTEM_DIRTY}
    else
        true
        # TODO save a list of all the failed runs
        # TODO more
    fi

    if test $(($SQ_THIS_RUN_INDEX + 1)) -ge ${#SQ_TEST_RUN_PERF_LIST[*]};then
        echo "$(date '+%Y-%m-%d-%H-%M-%S')" > ${SQ_TEST_CONTROL_FILE_DONE}
    fi
}

function sq_system_reboot {
    local _release=$1

    case ${_release} in
        SLE11SP3) sq_info "[CONTROL] Do not reboot in SLE11SP3";;
        SLE12) (/usr/bin/systemctl reboot) & ;;
        *) sq_info "[CONTROL] Not implement rebooting in ${_release}";;
    esac
}

function sq_control_try_reboot_system {
    if test -f ${SQ_TEST_CONTROL_FILE_STOP};then
        sq_info "[CONTROL]: runs stopped"
        return
    fi
    if test -f ${SQ_TEST_CONTROL_FILE_DONE};then
        sq_info "[CONTROL]: runs done. NO reboot"
        return
    fi
    if test "X{SQ_TEST_CONTROL_MAKE_SYSTEM_PURE}" == "YES";then
        sq_info "[CONTROL]: try to reboot system."
        # set reboot at the exit of the script
        #TODU
    fi
    sq_info "[CONTROL] call reboot"
    sq_system_reboot ${SLE_RELEASE}
    exit
}

if test "x${SQ_TEST_DIR}" == "x";then
    sq_error "SQ_TEST_DIR is none." \
        "Please check the conf file."
    exit 1
fi

if test ! -d ${SQ_TEST_DIR};then
    mkdir -p ${SQ_TEST_DIR}
    mkdir -p ${SQ_TEST_RUN_DIR}
    mkdir -p ${SQ_TEST_CALL_DIR}
    mkdir -p ${SQ_TEST_CONTROL_DIR}
    mkdir -p ${SQ_TEST_LOG_DIR}
fi

sq_prep_all ${ARCH} ${SLE_BUILD} ${REPO_MIRROR}

SQ_TEST_CONTROL_IGNORE_SYSTEM_DIRTY=YES
SQ_TEST_CONTROL_MAKE_SYSTEM_PURE=NO

while sq_control_get_next_run;do
    sq_call_run ${SQ_THIS_RUN}
    sq_control_get_run_status $?
done
sq_control_try_reboot_system
